From cbd2e471be7dfbd0d06e42114afdbc627f026293 Mon Sep 17 00:00:00 2001
From: Ravi K <rkerur@gmail.com>
Date: Thu, 14 Jun 2012 16:51:06 -0700
Subject: [PATCH 2/2] OF 1.1 VLAN QinQ changes.

---
 datapath/actions.c                                 |   32 +++-
 datapath/datapath.c                                |    8 +-
 datapath/datapath.h                                |    2 +
 datapath/flow.c                                    |  108 ++++++++++--
 datapath/flow.h                                    |    4 +
 datapath/linux/compat/include/linux/if_vlan.h      |   37 ++++
 .../linux/compat/include/linux/netfilter_bridge.h  |    1 +
 datapath/linux/compat/netdevice.c                  |    9 +-
 datapath/tunnel.c                                  |   78 ++++++---
 datapath/vlan.c                                    |   42 +++++
 datapath/vlan.h                                    |   33 ++++-
 datapath/vport-gre.c                               |    3 +-
 datapath/vport-internal_dev.c                      |    2 +
 datapath/vport-netdev.c                            |   88 ++++++++--
 datapath/vport.h                                   |    7 +-
 include/linux/openvswitch.h                        |   11 +-
 include/openflow/nicira-ext.h                      |   48 +++++
 lib/bond.c                                         |    2 +-
 lib/cfm.c                                          |    2 +-
 lib/classifier.c                                   |   47 +++++-
 lib/classifier.h                                   |    3 +
 lib/dpif-netdev.c                                  |    3 +-
 lib/flow.c                                         |  121 ++++++++++++--
 lib/flow.h                                         |   24 ++-
 lib/learn.c                                        |    2 +-
 lib/meta-flow.c                                    |  116 +++++++++++++
 lib/meta-flow.h                                    |    8 +
 lib/nx-match.c                                     |   16 ++-
 lib/nx-match.h                                     |    2 +-
 lib/odp-util.c                                     |  120 ++++++++++++-
 lib/odp-util.h                                     |    3 +-
 lib/ofp-parse.c                                    |    6 +
 lib/ofp-print.c                                    |    6 +
 lib/ofp-util.c                                     |   37 ++++-
 lib/ofp-util.def                                   |    1 +
 lib/packets.c                                      |   15 +-
 lib/packets.h                                      |    9 +-
 ofproto/ofproto-dpif.c                             |   51 +++++-
 tests/odp.at                                       |   36 ++++-
 tests/ofp-print.at                                 |    4 +-
 tests/ofproto-dpif.at                              |  182 ++++++++++++--------
 tests/ofproto.at                                   |   10 +-
 utilities/ovs-dpctl.c                              |    2 +
 utilities/ovs-ofctl.8.in                           |   18 ++
 44 files changed, 1138 insertions(+), 221 deletions(-)

diff --git a/datapath/actions.c b/datapath/actions.c
index c02e007..fa4be20 100644
--- a/datapath/actions.c
+++ b/datapath/actions.c
@@ -82,8 +82,9 @@ static int pop_vlan(struct sk_buff *skb)
 	if (likely(vlan_tx_tag_present(skb))) {
 		vlan_set_tci(skb, 0);
 	} else {
-		if (unlikely(skb->protocol != htons(ETH_P_8021Q) ||
-			     skb->len < VLAN_ETH_HLEN))
+		if (unlikely((skb->protocol != htons(ETH_P_8021Q) &&
+					  skb->protocol != htons(ETH_P_8021AD)) ||
+					  skb->len < VLAN_ETH_HLEN))
 			return 0;
 
 		err = __pop_vlan_tci(skb, &tci);
@@ -91,8 +92,9 @@ static int pop_vlan(struct sk_buff *skb)
 			return err;
 	}
 	/* move next vlan tag to hw accel tag */
-	if (likely(skb->protocol != htons(ETH_P_8021Q) ||
-		   skb->len < VLAN_ETH_HLEN))
+	if (likely((skb->protocol != htons(ETH_P_8021Q) &&
+				skb->protocol != htons(ETH_P_8021AD)) ||
+				skb->len < VLAN_ETH_HLEN))
 		return 0;
 
 	err = __pop_vlan_tci(skb, &tci);
@@ -111,8 +113,13 @@ static int push_vlan(struct sk_buff *skb, const struct ovs_action_push_vlan *vla
 		/* push down current VLAN tag */
 		current_tag = vlan_tx_tag_get(skb);
 
-		if (!__vlan_put_tag(skb, current_tag))
-			return -ENOMEM;
+		if (skb->protocol == htons(ETH_P_8021AD)) {
+			if (!__vlan_put_qinq_tag(skb, current_tag))
+				return -ENOMEM;
+		} else {
+			if (!__vlan_put_tag(skb, current_tag))
+				return -ENOMEM;
+		}
 
 		if (get_ip_summed(skb) == OVS_CSUM_COMPLETE)
 			skb->csum = csum_add(skb->csum, csum_partial(skb->data
@@ -120,6 +127,7 @@ static int push_vlan(struct sk_buff *skb, const struct ovs_action_push_vlan *vla
 
 	}
 	__vlan_hwaccel_put_tag(skb, ntohs(vlan->vlan_tci) & ~VLAN_TAG_PRESENT);
+	vlan_set_tpid(skb, vlan->vlan_tpid);
 	return 0;
 }
 
@@ -149,7 +157,8 @@ static char *get_mpls_hdr(const struct sk_buff *skb)
 		dl_type = eth->h_proto;
 
 	/* Check for a VLAN tag. */
-	while (dl_type == htons(ETH_P_8021Q) &&
+	while ((dl_type == htons(ETH_P_8021Q) ||
+			dl_type == htons(ETH_P_8021AD)) &&
 			skb->len >= nh_ofs + sizeof(struct vlan_hdr)) {
 		struct vlan_hdr *vh = (struct vlan_hdr*)(skb->data + nh_ofs);
 		dl_type = vh->h_vlan_encapsulated_proto;
@@ -173,7 +182,8 @@ static char *get_next_mpls_hdr(const struct sk_buff *skb)
 		dl_type = eth->h_proto;
 
 	/* Check for a VLAN tag. */
-	while (dl_type == htons(ETH_P_8021Q) &&
+	while ((dl_type == htons(ETH_P_8021Q) ||
+			dl_type == htons(ETH_P_8021AD)) &&
 			skb->len >= nh_ofs + sizeof(struct vlan_hdr)) {
 		struct vlan_hdr *vh = (struct vlan_hdr*)(skb->data + nh_ofs);
 		dl_type = vh->h_vlan_encapsulated_proto;
@@ -195,7 +205,8 @@ static __be16 get_ethertype(struct sk_buff *skb)
 	struct ethhdr *eth = eth_hdr(skb);
 	__be16 eth_type = htons(0);
 	if (likely(ntohs(eth->h_proto) >= ETH_TYPE_MIN)) {
-		if (eth->h_proto == htons(ETH_P_8021Q)) {
+		if (eth->h_proto == htons(ETH_P_8021Q) ||
+			eth->h_proto == htons(ETH_P_8021AD)) {
 			eth_type = *(__be16 *)(get_mpls_hdr(skb) - 2);
 			return eth_type;
 		} else {
@@ -211,7 +222,8 @@ static void set_ethertype(struct sk_buff *skb, __be16 eth_type)
 {
 	struct ethhdr *eth = eth_hdr(skb);
 	if (likely(ntohs(eth->h_proto) >= ETH_TYPE_MIN)) {
-		if (eth->h_proto != htons(ETH_P_8021Q)) {
+		if (eth->h_proto != htons(ETH_P_8021Q) &&
+			eth->h_proto != htons(ETH_P_8021AD)) {
 			skb->protocol = eth->h_proto = eth_type;
         } else {
 			/* 2 bytes before L2.5(MPLS) or L3 header is the
diff --git a/datapath/datapath.c b/datapath/datapath.c
index 2126e2c..6811b61 100644
--- a/datapath/datapath.c
+++ b/datapath/datapath.c
@@ -466,6 +466,11 @@ static int queue_userspace_packet(struct net *net, int dp_ifindex,
 		if (err)
 			return err;
 
+		if (vlan_tx_qinq_tag_present(skb)) {
+			err = vlan_deaccel_qinq_tag(nskb);
+			if (err)
+				return err;
+		}
 		skb = nskb;
 	}
 
@@ -705,7 +710,8 @@ static int validate_actions(const struct nlattr *attr,
 
 		case OVS_ACTION_ATTR_PUSH_VLAN:
 			vlan = nla_data(a);
-			if (vlan->vlan_tpid != htons(ETH_P_8021Q))
+			if (vlan->vlan_tpid != htons(ETH_P_8021Q) &&
+				vlan->vlan_tpid != htons(ETH_P_8021AD))
 				return -EINVAL;
 			if (!(vlan->vlan_tci & htons(VLAN_TAG_PRESENT)))
 				return -EINVAL;
diff --git a/datapath/datapath.h b/datapath/datapath.h
index affbf0e..feb7107 100644
--- a/datapath/datapath.h
+++ b/datapath/datapath.h
@@ -115,6 +115,8 @@ struct ovs_skb_cb {
 #ifdef NEED_VLAN_FIELD
 	u16			vlan_tci;
 #endif
+	__be16		vlan_tpid;
+	u16			vlan_qinq_tci;
 };
 #define OVS_CB(skb) ((struct ovs_skb_cb *)(skb)->cb)
 
diff --git a/datapath/flow.c b/datapath/flow.c
index d07753a..0517377 100644
--- a/datapath/flow.c
+++ b/datapath/flow.c
@@ -460,7 +460,7 @@ void ovs_flow_deferred_free_acts(struct sw_flow_actions *sf_acts)
 static int parse_vlan(struct sk_buff *skb, struct sw_flow_key *key)
 {
 	struct qtag_prefix {
-		__be16 eth_type; /* ETH_P_8021Q */
+		__be16 eth_type; /* ETH_P_8021Q or ETH_P_8021AD. */
 		__be16 tci;
 	};
 	struct qtag_prefix *qp;
@@ -474,6 +474,29 @@ static int parse_vlan(struct sk_buff *skb, struct sw_flow_key *key)
 
 	qp = (struct qtag_prefix *) skb->data;
 	key->eth.tci = qp->tci | htons(VLAN_TAG_PRESENT);
+	key->vlan.type = qp->eth_type;
+	__skb_pull(skb, sizeof(struct qtag_prefix));
+
+	return 0;
+}
+
+static int parse_vlan_qinq(struct sk_buff *skb, struct sw_flow_key *key)
+{
+	struct qtag_prefix {
+		__be16 eth_type; /* ETH_P_8021Q */
+		__be16 tci;
+	};
+	struct qtag_prefix *qp;
+
+	if (unlikely(skb->len < sizeof(struct qtag_prefix) + sizeof(__be16)))
+		return 0;
+
+	if (unlikely(!pskb_may_pull(skb, sizeof(struct qtag_prefix) +
+					 sizeof(__be16))))
+		return -ENOMEM;
+
+	qp = (struct qtag_prefix *) skb->data;
+	key->vlan.qinq_tci = qp->tci | htons(VLAN_TAG_PRESENT);
 	__skb_pull(skb, sizeof(struct qtag_prefix));
 
 	return 0;
@@ -693,11 +716,37 @@ int ovs_flow_extract(struct sk_buff *skb, u16 in_port, struct sw_flow_key *key,
 
 	__skb_pull(skb, 2 * ETH_ALEN);
 
-	if (vlan_tx_tag_present(skb))
+	if (vlan_tx_tag_present(skb)) {
 		key->eth.tci = htons(vlan_get_tci(skb));
-	else if (eth->h_proto == htons(ETH_P_8021Q))
+		key->vlan.type = skb->protocol;
+		if (vlan_tx_qinq_tag_present(skb)) {
+			key->vlan.qinq_tci = htons(vlan_get_qinq_tci(skb));
+			key_len = SW_FLOW_KEY_OFFSET(vlan.qinq_tci);
+		} else {
+			/* Find next tpid if present. */
+			__be16 proto;
+			proto = *(__be16 *) skb->data;
+			if (proto == htons(ETH_P_8021Q)) {
+				if (unlikely(parse_vlan_qinq(skb, key)))
+					return -ENOMEM;
+				key_len = SW_FLOW_KEY_OFFSET(vlan.qinq_tci);
+			}
+		}
+	} else if (eth->h_proto == htons(ETH_P_8021Q) ||
+			   eth->h_proto == htons(ETH_P_8021AD)) {
 		if (unlikely(parse_vlan(skb, key)))
 			return -ENOMEM;
+		else {
+			/* Find next tpid if present. */
+			__be16 proto;
+			proto = *(__be16 *) skb->data;
+			if (proto == htons(ETH_P_8021Q)) {
+				if (unlikely(parse_vlan_qinq(skb, key)))
+					return -ENOMEM;
+				key_len = SW_FLOW_KEY_OFFSET(vlan.qinq_tci);
+			}
+		}
+	}
 
 	key->eth.type = parse_ethertype(skb);
 	if (unlikely(key->eth.type == htons(0)))
@@ -906,6 +955,7 @@ const int ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {
 	[OVS_KEY_ATTR_ARP] = sizeof(struct ovs_key_arp),
 	[OVS_KEY_ATTR_ND] = sizeof(struct ovs_key_nd),
 	[OVS_KEY_ATTR_MPLS] = sizeof(__be32),
+	[OVS_KEY_ATTR_VLAN_QINQ] = sizeof(__be16),
 
 	/* Not upstream. */
 	[OVS_KEY_ATTR_TUN_ID] = sizeof(__be64),
@@ -1099,20 +1149,39 @@ int ovs_flow_from_nlattrs(struct sw_flow_key *swkey, int *key_lenp,
 	memcpy(swkey->eth.dst, eth_key->eth_dst, ETH_ALEN);
 
 	if (attrs & (1u << OVS_KEY_ATTR_ETHERTYPE) &&
-	    nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q)) {
+	    (nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q) ||
+		 nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021AD))) {
 		const struct nlattr *encap;
-		__be16 tci;
+		__be16 tci, qinq_tci;
+		__be16 tpid;
 
-		if (attrs != ((1 << OVS_KEY_ATTR_VLAN) |
-			      (1 << OVS_KEY_ATTR_ETHERTYPE) |
-			      (1 << OVS_KEY_ATTR_ENCAP)))
+		if (!(attrs & ((1 << OVS_KEY_ATTR_VLAN) |
+			           (1 << OVS_KEY_ATTR_ETHERTYPE) |
+					   (1 << OVS_KEY_ATTR_ENCAP))))
 			return -EINVAL;
 
 		encap = a[OVS_KEY_ATTR_ENCAP];
 		tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);
+		tpid = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);
 		if (tci & htons(VLAN_TAG_PRESENT)) {
 			swkey->eth.tci = tci;
-
+			swkey->vlan.type = tpid;
+
+			/* Handle vlan qinq if present. */
+			if (attrs & (1 << OVS_KEY_ATTR_VLAN_QINQ)) {
+				qinq_tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN_QINQ]);
+				if (qinq_tci & htons(VLAN_TAG_PRESENT)) {
+					swkey->vlan.qinq_tci = qinq_tci;
+				} else if (!qinq_tci) {
+					/* Corner case for truncated 802.1AD header. */
+					*key_lenp = key_len;
+					return 0;
+				} else {
+					return -EINVAL;
+				}
+				attrs &= ~(1 << OVS_KEY_ATTR_VLAN_QINQ);
+				key_len = SW_FLOW_KEY_OFFSET(vlan.qinq_tci);
+			}
 			err = parse_flow_nlattrs(encap, a, &attrs);
 			if (err)
 				return err;
@@ -1121,7 +1190,7 @@ int ovs_flow_from_nlattrs(struct sw_flow_key *swkey, int *key_lenp,
 			if (nla_len(encap))
 				return -EINVAL;
 
-			swkey->eth.type = htons(ETH_P_8021Q);
+			swkey->eth.type = tpid;
 			*key_lenp = key_len;
 			return 0;
 		} else {
@@ -1301,10 +1370,21 @@ int ovs_flow_to_nlattrs(const struct sw_flow_key *swkey, struct sk_buff *skb)
 	memcpy(eth_key->eth_src, swkey->eth.src, ETH_ALEN);
 	memcpy(eth_key->eth_dst, swkey->eth.dst, ETH_ALEN);
 
-	if (swkey->eth.tci || swkey->eth.type == htons(ETH_P_8021Q)) {
-		if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, htons(ETH_P_8021Q)) ||
-		    nla_put_be16(skb, OVS_KEY_ATTR_VLAN, swkey->eth.tci))
-			goto nla_put_failure;
+	if (swkey->eth.tci ||
+		swkey->eth.type == htons(ETH_P_8021Q) ||
+		swkey->vlan.qinq_tci) {
+		if (swkey->vlan.qinq_tci) {
+			if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, swkey->vlan.type) ||
+				nla_put_be16(skb, OVS_KEY_ATTR_VLAN, swkey->eth.tci) ||
+				nla_put_be16(skb, OVS_KEY_ATTR_VLAN_QINQ, swkey->vlan.qinq_tci)) {
+				goto nla_put_failure;
+			}
+		} else {
+			if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, htons(ETH_P_8021Q)) ||
+				nla_put_be16(skb, OVS_KEY_ATTR_VLAN, swkey->eth.tci)) {
+				goto nla_put_failure;
+			}
+		}
 		encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);
 		if (!swkey->eth.tci)
 			goto unencap;
diff --git a/datapath/flow.h b/datapath/flow.h
index aac8b4d..37b63fc 100644
--- a/datapath/flow.h
+++ b/datapath/flow.h
@@ -53,6 +53,10 @@ struct sw_flow_key {
 		__be16 type;		/* Ethernet frame type. */
 	} eth;
 	struct {
+		__be16 type;		/* VLAN qinq outer frame type either 0x8100 or 0x88a8. */
+		__be16 qinq_tci;	/* 0 if no VLAN, VLAN_TAG_PRESENT set otherwise. */
+	} vlan;
+	struct {
 		__be32 mpls_lse;	/* 0 if no MPLS, otherwise MPLS label Stack entry. */
 	} mpls;
 	struct {
diff --git a/datapath/linux/compat/include/linux/if_vlan.h b/datapath/linux/compat/include/linux/if_vlan.h
index dc4b15e..ded61b9 100644
--- a/datapath/linux/compat/include/linux/if_vlan.h
+++ b/datapath/linux/compat/include/linux/if_vlan.h
@@ -5,6 +5,10 @@
 #include <linux/version.h>
 #include_next <linux/if_vlan.h>
 
+#ifndef                ETH_P_8021AD
+#define                ETH_P_8021AD            0x88a8
+#endif
+
 /*
  * The behavior of __vlan_put_tag() has changed over time:
  *
@@ -45,6 +49,39 @@ static inline struct sk_buff *__vlan_put_tag(struct sk_buff *skb, u16 vlan_tci)
 	return skb;
 }
 
+/*
+ * The behavior of __vlan_put_qinq_tag() is similar to __vlan_put_tag()
+ * it adds new vlan tpid 0x88a8 as an outer tag.
+ * Works for kernel version < 2.6.39.
+ * for kernel > 2.6.39, similar function needs to be added to upstream
+ * kernel.
+ *
+ */
+static inline struct sk_buff *
+__vlan_put_qinq_tag(struct sk_buff *skb, u16 vlan_tci)
+{
+	struct vlan_ethhdr *veth;
+
+	if (skb_cow_head(skb, VLAN_HLEN) < 0) {
+		kfree_skb(skb);
+		return NULL;
+	}
+	veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);
+
+	/* Move the mac addresses to the beginning of the new header. */
+	memmove(skb->data, skb->data + VLAN_HLEN, 2 * VLAN_ETH_ALEN);
+	skb->mac_header -= VLAN_HLEN;
+
+	/* first, the ethernet type */
+	veth->h_vlan_proto = htons(ETH_P_8021AD);
+
+	/* now, the TCI */
+	veth->h_vlan_TCI = htons(vlan_tci);
+
+	skb->protocol = htons(ETH_P_8021AD);
+
+	return skb;
+}
 
 /* All of these were introduced in a single commit preceding 2.6.33, so
  * presumably all of them or none of them are present. */
diff --git a/datapath/linux/compat/include/linux/netfilter_bridge.h b/datapath/linux/compat/include/linux/netfilter_bridge.h
index c526537..65884c8 100644
--- a/datapath/linux/compat/include/linux/netfilter_bridge.h
+++ b/datapath/linux/compat/include/linux/netfilter_bridge.h
@@ -13,6 +13,7 @@ static inline unsigned int nf_bridge_encap_header_len(const struct sk_buff *skb)
 {
 	switch (skb->protocol) {
 	case __constant_htons(ETH_P_8021Q):
+	case __constant_htons(ETH_P_8021AD):
 		return VLAN_HLEN;
 	default:
 		return 0;
diff --git a/datapath/linux/compat/netdevice.c b/datapath/linux/compat/netdevice.c
index 9e92eeb..b5ae776 100644
--- a/datapath/linux/compat/netdevice.c
+++ b/datapath/linux/compat/netdevice.c
@@ -52,7 +52,8 @@ u32 rpl_netif_skb_features(struct sk_buff *skb)
 	__be16 protocol = skb->protocol;
 	u32 features = skb->dev->features;
 
-	if (protocol == htons(ETH_P_8021Q)) {
+	if (protocol == htons(ETH_P_8021Q) ||
+		protocol == htons(ETH_P_8021AD)) {
 		struct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;
 		protocol = veh->h_vlan_encapsulated_proto;
 	} else if (!vlan_tx_tag_present(skb)) {
@@ -61,7 +62,8 @@ u32 rpl_netif_skb_features(struct sk_buff *skb)
 
 	features &= (vlan_features | NETIF_F_HW_VLAN_TX);
 
-	if (protocol != htons(ETH_P_8021Q)) {
+	if (protocol != htons(ETH_P_8021Q) &&
+		protocol != htons(ETH_P_8021AD)) {
 		return harmonize_features(skb, protocol, features);
 	} else {
 		features &= NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST |
@@ -77,7 +79,8 @@ struct sk_buff *rpl_skb_gso_segment(struct sk_buff *skb, u32 features)
 	__be16 skb_proto;
 	struct sk_buff *skb_gso;
 
-	while (type == htons(ETH_P_8021Q)) {
+	while (type == htons(ETH_P_8021Q) ||
+		   type == htons(ETH_P_8021AD)) {
 		struct vlan_hdr *vh;
 
 		if (unlikely(!pskb_may_pull(skb, vlan_depth + VLAN_HLEN)))
diff --git a/datapath/tunnel.c b/datapath/tunnel.c
index bbce412..f335056 100644
--- a/datapath/tunnel.c
+++ b/datapath/tunnel.c
@@ -394,11 +394,24 @@ static bool check_skb_mpls(struct sk_buff *skb, __be32 *mpls_entry)
 	return true;
 }
 
-/* Check VLAN/MPLS packets. */
-static bool check_skb_vlan_mpls(struct sk_buff *skb, __be32 *mpls_entry)
+/* Check VLAN-QinQ/MPLS or VLAN/MPLS packets. */
+static bool check_skb_vlan_qinq_mpls(struct sk_buff *skb, __be32 *mpls_entry)
 {
 	__be32 mpls_lse = htonl(0);
 	unsigned int mpls_lse_len = MPLS_HLEN;
+    unsigned int vlan_hlen = 0;
+
+	/* Handle VLAN-QinQ/MPLS encapsulated packets. */
+	if (skb->protocol == htons(ETH_P_8021Q)) {
+
+		if (unlikely(!pskb_may_pull(skb, VLAN_HLEN + mpls_lse_len)))
+			return false;
+
+		skb_set_network_header(skb, skb_network_offset(skb) + VLAN_HLEN);
+		skb->protocol = *(__be16 *)(skb->data + VLAN_ETH_HLEN + 2);
+        vlan_hlen += VLAN_ETH_HLEN;
+        mpls_lse_len = 0;
+    }
 
 	/* Handle VLAN/MPLS encapsulated packets. */
 	if (skb->protocol == htons(ETH_P_MPLS_UC) ||
@@ -408,12 +421,12 @@ static bool check_skb_vlan_mpls(struct sk_buff *skb, __be32 *mpls_entry)
 		}
 
 		*mpls_entry = mpls_lse = *(__be32 *)(skb->data + VLAN_ETH_HLEN);
-
+		mpls_lse_len = MPLS_HLEN;
 		while (!(mpls_lse & htonl(MPLS_STACK_MASK))) {
 			if (unlikely(!pskb_may_pull(skb, mpls_lse_len))) {
 				return false;
 			}
-			mpls_lse = *(__be32 *)(skb->data + VLAN_ETH_HLEN + mpls_lse_len);
+			mpls_lse = *(__be32 *)(skb->data + vlan_hlen + mpls_lse_len);
 			mpls_lse_len += MPLS_HLEN;
 		}
 		skb_set_network_header(skb, skb_network_offset(skb) + mpls_lse_len);
@@ -429,15 +442,16 @@ static void ecn_decapsulate(struct sk_buff *skb, u8 tos)
 
 		skb_set_network_header(skb, ETH_HLEN);
 
-		if (skb->protocol == htons(ETH_P_8021Q)) {
+		if (skb->protocol == htons(ETH_P_8021Q) ||
+			skb->protocol == htons(ETH_P_8021AD)) {
 			if (unlikely(!pskb_may_pull(skb, VLAN_ETH_HLEN)))
 				return;
 
 			skb->protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
 			skb_set_network_header(skb, VLAN_ETH_HLEN);
 
-			/* Handle VLAN/MPLS encapsulated packets. */
-			if (!check_skb_vlan_mpls(skb, &mpls_lse))
+			/* Handle VLAN-QinQ/MPLS or VLAN/MPLS encapsulated packets. */
+			if (!check_skb_vlan_qinq_mpls(skb, &mpls_lse))
 				return;
 		} else {
 			if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
@@ -514,6 +528,7 @@ void ovs_tnl_rcv(struct vport *vport, struct sk_buff *skb, u8 tos)
 
 	ecn_decapsulate(skb, tos);
 	vlan_set_tci(skb, 0);
+	vlan_set_qinq_tci(skb, 0);
 
 	if (unlikely(compute_ip_summed(skb, false))) {
 		kfree_skb(skb);
@@ -715,9 +730,9 @@ void check_mpls_hlen(struct sk_buff *skb, unsigned int *mpls_hlen)
 	}
 }
 
-/* Check VLAN/MPLS packets. Do not modify skb. */
-void check_vlan_mpls_hlen(struct sk_buff *skb, unsigned int *vlan_hlen,
-						  unsigned int *mpls_hlen)
+/* Check VLAN-QinQ/MPLS or VLAN/MPLS or MPLS packets. Do not modify skb. */
+void check_vlan_qinq_mpls_hlen(struct sk_buff *skb, unsigned int *vlan_hlen,
+							   unsigned int *mpls_hlen)
 {
 	__be16 protocol;
 	__be32 mpls_lse = htonl(0);
@@ -729,7 +744,8 @@ void check_vlan_mpls_hlen(struct sk_buff *skb, unsigned int *vlan_hlen,
 		*vlan_hlen += VLAN_HLEN;
 	}
 
-	while (protocol == htons(ETH_P_8021Q)) {
+	while (protocol == htons(ETH_P_8021Q) ||
+		   protocol == htons(ETH_P_8021AD)) {
 		struct vlan_hdr *vh;
 
 		if (unlikely(!pskb_may_pull(skb, total_hlen + VLAN_HLEN)))
@@ -793,10 +809,11 @@ bool ovs_tnl_frag_needed(struct vport *vport,
 		return false;
 
 	/* Allocate */
-	if (old_eh->h_proto == htons(ETH_P_8021Q)) {
+	if (old_eh->h_proto == htons(ETH_P_8021Q) ||
+		old_eh->h_proto == htons(ETH_P_8021AD)) {
 
 		eth_hdr_len = VLAN_ETH_HLEN;
-		check_vlan_mpls_hlen(skb, &eth_hdr_len, &mpls_hdr_len);
+		check_vlan_qinq_mpls_hlen(skb, &eth_hdr_len, &mpls_hdr_len);
 	} else {
 		check_mpls_hlen(skb, &mpls_hdr_len);
 	}
@@ -830,13 +847,16 @@ bool ovs_tnl_frag_needed(struct vport *vport,
 	memcpy(eh->h_dest, old_eh->h_source, ETH_ALEN);
 	memcpy(eh->h_source, mutable->eth_addr, ETH_ALEN);
 	nskb->protocol = eh->h_proto = old_eh->h_proto;
-	if (old_eh->h_proto == htons(ETH_P_8021Q)) {
+	if (old_eh->h_proto == htons(ETH_P_8021Q) ||
+		old_eh->h_proto == htons(ETH_P_8021AD)) {
 		struct vlan_ethhdr *vh = (struct vlan_ethhdr *)eh;
 
 		vh->h_vlan_TCI = vlan_eth_hdr(skb)->h_vlan_TCI;
 		vh->h_vlan_encapsulated_proto = skb->protocol;
-	} else
+	} else {
 		vlan_set_tci(nskb, vlan_get_tci(skb));
+		vlan_set_qinq_tci(nskb, vlan_get_qinq_tci(skb));
+	}
 	skb_reset_mac_header(nskb);
 
 	/* Protocol */
@@ -883,11 +903,12 @@ static bool check_mtu(struct sk_buff *skb,
 	/* Allow for one level of tagging and allow mpls headers
 	 * in the packet length. */
 	if (!vlan_tx_tag_present(skb) &&
-	    eth_hdr(skb)->h_proto == htons(ETH_P_8021Q)) {
+	    (eth_hdr(skb)->h_proto == htons(ETH_P_8021Q) ||
+		 eth_hdr(skb)->h_proto == htons(ETH_P_8021AD))) {
 
 		packet_length -= VLAN_HLEN;
-		check_vlan_mpls_hlen(skb, &vlan_hlen, &mpls_hlen);
-		packet_length = packet_length - mpls_hlen;
+		check_vlan_qinq_mpls_hlen(skb, &vlan_hlen, &mpls_hlen);
+		packet_length = packet_length - mpls_hlen - vlan_hlen;
 	} else {
 		check_mpls_hlen(skb, &mpls_hlen);
 		packet_length -= mpls_hlen;
@@ -900,9 +921,10 @@ static bool check_mtu(struct sk_buff *skb,
 		 * currently is, so subtract it from the MTU.
 		 */
 		if (vlan_tx_tag_present(skb) ||
-		    eth_hdr(skb)->h_proto == htons(ETH_P_8021Q)) {
+		    eth_hdr(skb)->h_proto == htons(ETH_P_8021Q) ||
+			eth_hdr(skb)->h_proto == htons(ETH_P_8021AD)) {
 			vlan_header = VLAN_HLEN;
-			check_vlan_mpls_hlen(skb, &vlan_header, &mpls_header);
+			check_vlan_qinq_mpls_hlen(skb, &vlan_header, &mpls_header);
 		} else {
 			check_mpls_hlen(skb, &mpls_header);
 		}
@@ -1246,7 +1268,7 @@ static struct sk_buff *handle_offloads(struct sk_buff *skb,
 	int err;
 	unsigned int vlan_hlen = 0, mpls_hlen = 0;
 
-	check_vlan_mpls_hlen(skb, &vlan_hlen, &mpls_hlen);
+	check_vlan_qinq_mpls_hlen(skb, &vlan_hlen, &mpls_hlen);
 	min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len
 			+ mutable->tunnel_hlen
 			+ (vlan_tx_tag_present(skb) ? VLAN_HLEN : 0)
@@ -1267,13 +1289,13 @@ static struct sk_buff *handle_offloads(struct sk_buff *skb,
 	if (skb_is_gso(skb)) {
 		struct sk_buff *nskb;
 
-		if (mpls_tag_present(skb)) {
+		if (mpls_tag_present(skb) || vlan_qinq_tag_present(skb)) {
 			/* skb_gso_segment depends on skb->protocol, save and
 			 * restore after the call. */
 			__be16 tmp_protocol = skb->protocol;
 
 			/* Handle MPLS encapsulated packets. */
-			check_skb_vlan_mpls_protocol(skb);
+			check_skb_vlan_qinq_mpls_protocol(skb);
             nskb = skb_gso_segment(skb, 0);
             skb->protocol = tmp_protocol;
 		} else {
@@ -1365,7 +1387,8 @@ int ovs_tnl_send(struct vport *vport, struct sk_buff *skb)
 	u8 tos;
 
 	/* Validate the protocol headers before we try to use them. */
-	if (skb->protocol == htons(ETH_P_8021Q) &&
+	if ((skb->protocol == htons(ETH_P_8021Q) ||
+		 skb->protocol == htons(ETH_P_8021AD)) &&
 	    !vlan_tx_tag_present(skb)) {
 		if (unlikely(!pskb_may_pull(skb, VLAN_ETH_HLEN)))
 			goto error_free;
@@ -1373,8 +1396,8 @@ int ovs_tnl_send(struct vport *vport, struct sk_buff *skb)
 		skb->protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
 		skb_set_network_header(skb, VLAN_ETH_HLEN);
 
-		/* Handle VLAN/MPLS encapsulated packets. */
-		if (!check_skb_vlan_mpls(skb, &mpls_lse))
+		/* Handle VLAN-QinQ/MPLS or VLAN/MPLS encapsulated packets. */
+		if (!check_skb_vlan_qinq_mpls(skb, &mpls_lse))
 			goto error_free;
 	} else {
 		if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
@@ -1485,6 +1508,9 @@ int ovs_tnl_send(struct vport *vport, struct sk_buff *skb)
 		if (unlikely(vlan_deaccel_tag(skb)))
 			goto next;
 
+		if (unlikely(vlan_deaccel_qinq_tag(skb)))
+			goto next;
+
 		if (likely(cache)) {
 			skb_push(skb, cache->len);
 			memcpy(skb->data, get_cached_header(cache), cache->len);
diff --git a/datapath/vlan.c b/datapath/vlan.c
index 104ed55..ebcf965 100644
--- a/datapath/vlan.c
+++ b/datapath/vlan.c
@@ -55,4 +55,46 @@ struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb, u16 vlan_tci)
 	OVS_CB(skb)->vlan_tci = vlan_tci | VLAN_TAG_PRESENT;
 	return skb;
 }
+
 #endif /* NEED_VLAN_FIELD */
+
+__be16 vlan_get_tpid(struct sk_buff *skb)
+{
+	return OVS_CB(skb)->vlan_tpid;
+}
+
+void vlan_set_tpid(struct sk_buff *skb, __be16 vlan_tpid)
+{
+	OVS_CB(skb)->vlan_tpid = vlan_tpid;
+}
+
+void vlan_copy_skb_qinq_tci(struct sk_buff *skb)
+{
+	OVS_CB(skb)->vlan_qinq_tci = 0;
+}
+
+u16 vlan_get_qinq_tci(struct sk_buff *skb)
+{
+	return OVS_CB(skb)->vlan_qinq_tci;
+}
+
+void vlan_set_qinq_tci(struct sk_buff *skb, u16 vlan_qinq_tci)
+{
+	OVS_CB(skb)->vlan_qinq_tci = vlan_qinq_tci;
+}
+
+bool vlan_tx_qinq_tag_present(struct sk_buff *skb)
+{
+	return OVS_CB(skb)->vlan_qinq_tci & VLAN_TAG_PRESENT;
+}
+
+u16 vlan_tx_qinq_tag_get(struct sk_buff *skb)
+{
+	return OVS_CB(skb)->vlan_qinq_tci & ~VLAN_TAG_PRESENT;
+}
+
+struct sk_buff *__vlan_hwaccel_put_qinq_tag(struct sk_buff *skb, u16 vlan_qinq_tci)
+{
+	OVS_CB(skb)->vlan_qinq_tci = vlan_qinq_tci | VLAN_TAG_PRESENT;
+	return skb;
+}
diff --git a/datapath/vlan.h b/datapath/vlan.h
index 5d3573b..8036aa2 100644
--- a/datapath/vlan.h
+++ b/datapath/vlan.h
@@ -84,17 +84,44 @@ u16 vlan_tx_tag_get(struct sk_buff *skb);
 struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb, u16 vlan_tci);
 #endif /* NEED_VLAN_FIELD */
 
+__be16 vlan_get_tpid(struct sk_buff *skb);
+void vlan_set_tpid(struct sk_buff *skb, __be16 vlan_tpid);
+void vlan_copy_skb_qinq_tci(struct sk_buff *skb);
+u16 vlan_get_qinq_tci(struct sk_buff *skb);
+void vlan_set_qinq_tci(struct sk_buff *skb, u16 vlan_tci);
+bool vlan_tx_qinq_tag_present(struct sk_buff *skb);
+u16 vlan_tx_qinq_tag_get(struct sk_buff *skb);
+struct sk_buff *__vlan_hwaccel_put_qinq_tag(struct sk_buff *skb, u16 vlan_tci);
+
 static inline int vlan_deaccel_tag(struct sk_buff *skb)
 {
 	if (!vlan_tx_tag_present(skb))
 		return 0;
 
-	skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
-	if (unlikely(!skb))
-		return -ENOMEM;
+	if (skb->protocol == htons(ETH_P_8021AD)) {
+		skb = __vlan_put_qinq_tag(skb, vlan_tx_tag_get(skb));
+		if (unlikely(!skb))
+			return -ENOMEM;
+	} else {
+		skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
+		if (unlikely(!skb))
+			return -ENOMEM;
+	}
 
 	vlan_set_tci(skb, 0);
 	return 0;
 }
 
+static inline int vlan_deaccel_qinq_tag(struct sk_buff *skb)
+{
+	if (!vlan_tx_qinq_tag_present(skb))
+		return 0;
+
+	skb = __vlan_put_tag(skb, vlan_tx_qinq_tag_get(skb));
+	if (unlikely(!skb))
+		return -ENOMEM;
+
+	vlan_set_qinq_tci(skb, 0);
+	return 0;
+}
 #endif /* vlan.h */
diff --git a/datapath/vport-gre.c b/datapath/vport-gre.c
index 471f66b..bf428b1 100644
--- a/datapath/vport-gre.c
+++ b/datapath/vport-gre.c
@@ -253,7 +253,8 @@ static void gre_err(struct sk_buff *skb, u32 info)
 	tot_hdr_len = tunnel_hdr_len + ETH_HLEN;
 
 	skb->protocol = eth_hdr(skb)->h_proto;
-	if (skb->protocol == htons(ETH_P_8021Q)) {
+	if (skb->protocol == htons(ETH_P_8021Q) ||
+		skb->protocol == htons(ETH_P_8021AD)) {
 		tot_hdr_len += VLAN_HLEN;
 		skb->protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
 	}
diff --git a/datapath/vport-internal_dev.c b/datapath/vport-internal_dev.c
index 595e23d..3383590 100644
--- a/datapath/vport-internal_dev.c
+++ b/datapath/vport-internal_dev.c
@@ -298,6 +298,8 @@ static int internal_dev_recv(struct vport *vport, struct sk_buff *skb)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
 	if (unlikely(vlan_deaccel_tag(skb)))
 		return 0;
+	if (unlikely(vlan_deaccel_qinq_tag(skb)))
+		return 0;
 #endif
 
 	len = skb->len;
diff --git a/datapath/vport-netdev.c b/datapath/vport-netdev.c
index 0848cbd..6e365e9 100644
--- a/datapath/vport-netdev.c
+++ b/datapath/vport-netdev.c
@@ -47,8 +47,8 @@ MODULE_PARM_DESC(vlan_tso, "Enable TSO for VLAN packets");
 
 /* Currently MPLS support is not available in kernel, so use the #define
  * to control MPLS offload capability.
- * mpls_tso = 0, use OVS offload simulation.
- * mpls_tso = 1, use Linux kernel generic offload code. */
+ * mpls_tso/vlan_qinq_tso = 0, use OVS offload simulation.
+ * mpls_tso/vlan_qinq_tso = 1, use Linux kernel generic offload code. */
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
 #include <linux/module.h>
@@ -60,6 +60,16 @@ MODULE_PARM_DESC(mpls_tso, "Enable TSO for MPLS packets");
 #define mpls_tso true
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#include <linux/module.h>
+
+static int vlan_qinq_tso __read_mostly;
+module_param(vlan_qinq_tso, int, 0644);
+MODULE_PARM_DESC(vlan_qinq_tso, "Enable TSO for VLAN QinQ packets");
+#else
+#define vlan_qinq_tso true
+#endif
+
 static void netdev_port_receive(struct vport *vport, struct sk_buff *skb);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
@@ -293,14 +303,15 @@ static unsigned int packet_length(struct sk_buff *skb)
 	unsigned int length = skb->len - ETH_HLEN;
 	unsigned int vlan_hlen = 0, mpls_hlen = 0;
 
-	if (skb->protocol == htons(ETH_P_8021Q)) {
+	if (skb->protocol == htons(ETH_P_8021Q) ||
+		skb->protocol == htons(ETH_P_8021AD)) {
 
 		length -= VLAN_HLEN;
 		vlan_hlen = VLAN_HLEN;
 	}
 
-	/* Handle VLAN/MPLS or MPLS encapsulated packets. */
-	check_vlan_mpls_hlen(skb, &vlan_hlen, &mpls_hlen);
+	/* Handle VLAN-QinQ/MPLS, VLAN/MPLS or MPLS encapsulated packets. */
+	check_vlan_qinq_mpls_hlen(skb, &vlan_hlen, &mpls_hlen);
 	length = length - vlan_hlen - mpls_hlen;
 
 	return length;
@@ -319,6 +330,31 @@ static bool dev_supports_vlan_tx(struct net_device *dev)
 #endif
 }
 
+/* Check for VLAN QinQ header present. */
+bool vlan_qinq_tag_present(struct sk_buff *skb)
+{
+	if (!vlan_qinq_tso) {
+		__be16 protocol = htons(0);
+
+		if (unlikely(!pskb_may_pull(skb, VLAN_ETH_HLEN + VLAN_HLEN)))
+			return false;
+
+		if (vlan_tx_tag_present(skb)) {
+			if (vlan_tx_qinq_tag_present(skb))
+				return true;
+			else {
+				protocol = eth_hdr(skb)->h_proto;
+				return (protocol == htons(ETH_P_8021Q));
+			}
+		} else if (skb->protocol == htons(ETH_P_8021Q) ||
+				   skb->protocol == htons(ETH_P_8021AD)) {
+			protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
+		}
+		return (protocol == htons(ETH_P_8021Q));
+	} else
+		return false;
+}
+
 /* Check for MPLS header presence. */
 bool mpls_tag_present(struct sk_buff *skb)
 {
@@ -344,14 +380,15 @@ bool mpls_tag_present(struct sk_buff *skb)
 		return false;
 }
 
-/* Get protocol after MPLS or VLAN/MPLS header. */
-void check_skb_vlan_mpls_protocol(struct sk_buff *skb)
+/* Get protocol after MPLS or VLAN/MPLS or VLAN-QinQ/MPLS header. */
+void check_skb_vlan_qinq_mpls_protocol(struct sk_buff *skb)
 {
 	int vlan_depth = ETH_HLEN;
 	int vlan_hlen = 0;
 
 	/* Handle MPLS, VLAN/MPLS and VLAN-QinQ/MPLS encapsulated packets. */
-	while (skb->protocol == htons(ETH_P_8021Q)) {
+	while (skb->protocol == htons(ETH_P_8021Q) ||
+		   skb->protocol == htons(ETH_P_8021AD)) {
 		struct vlan_hdr *vh;
 
 		if (unlikely(!pskb_may_pull(skb, vlan_depth + VLAN_HLEN))) {
@@ -386,8 +423,8 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 {
 	struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
 	int mtu = netdev_vport->dev->mtu;
-	int len;
-	bool mpls_tag;
+	int len = 0;
+	bool mpls_tag, vlan_qinq_tag;
 
 	if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {
 		net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\n",
@@ -403,9 +440,10 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 	forward_ip_summed(skb, true);
 
 	mpls_tag = mpls_tag_present(skb);
+	vlan_qinq_tag = vlan_qinq_tag_present(skb);
 
-	/* Handle MPLS and VLAN packets(for kernel < 2.6.37). */
-	if (mpls_tag ||
+	/* Handle MPLS, VLAN QinQ and VLAN packets(for kernel < 2.6.37). */
+	if (mpls_tag || vlan_qinq_tag ||
 		(vlan_tx_tag_present(skb) && !dev_supports_vlan_tx(skb->dev))) {
 		int features;
 
@@ -414,7 +452,7 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 		if (vlan_tx_tag_present(skb) && !vlan_tso) {
 			features &= ~(NETIF_F_TSO | NETIF_F_TSO6 |
 						  NETIF_F_UFO | NETIF_F_FSO);
-		} else if (mpls_tag) {
+		} else if (mpls_tag || vlan_qinq_tag) {
 			features &= ~(NETIF_F_TSO | NETIF_F_TSO6 |
 						  NETIF_F_UFO | NETIF_F_FSO | NETIF_F_ALL_CSUM);
 		}
@@ -422,11 +460,11 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 		if (netif_needs_gso(skb, features)) {
 			struct sk_buff *nskb;
 
-			if (mpls_tag) {
+			if (mpls_tag || vlan_qinq_tag) {
 				/* skb_gso_segment depends on skb->protocol, save and
 				 * restore after the call. */
 				__be16 tmp_protocol = skb->protocol;
-				check_skb_vlan_mpls_protocol(skb);
+				check_skb_vlan_qinq_mpls_protocol(skb);
 				nskb = skb_gso_segment(skb, features);
 				skb->protocol = tmp_protocol;
 			} else {
@@ -455,12 +493,17 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 				nskb = skb->next;
 				skb->next = NULL;
 
-				/* VLAN packets (kernel < 2.6.37) or VLAN/MPLS packets. */
+				/* VLAN packets (kernel < 2.6.37) or VLAN/MPLS packets
+				 * or VLAN QinQ packets. */
 				if (vlan_tx_tag_present(skb)) {
-					skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
+					if (vlan_get_tpid(skb) == htons(ETH_P_8021AD))
+						skb = __vlan_put_qinq_tag(skb, vlan_tx_tag_get(skb));
+					else
+						skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
 					if (likely(skb)) {
 						len += skb->len;
 						vlan_set_tci(skb, 0);
+						vlan_set_qinq_tci(skb, 0);
 						dev_queue_xmit(skb);
 					}
 				} else {
@@ -475,7 +518,7 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 			} while (skb);
 
 			return len;
-		} else if (mpls_tag &&
+		} else if ((mpls_tag || vlan_qinq_tag) &&
 				   get_ip_summed(skb) == OVS_CSUM_PARTIAL) {
 			int err;
 			/* Linearize skb before calculating checksum. */
@@ -487,12 +530,17 @@ static int netdev_send(struct vport *vport, struct sk_buff *skb)
 		}
 
 tag:
-		/* VLAN packets (kernel < 2.6.37) or VLAN/MPLS packets. */
+		/* VLAN packets (kernel < 2.6.37) or VLAN/MPLS packets
+		 * or VLAN QinQ packets. */
 		if (vlan_tx_tag_present(skb)) {
-			skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
+			if (vlan_get_tpid(skb) == htons(ETH_P_8021AD))
+				skb = __vlan_put_qinq_tag(skb, vlan_tx_tag_get(skb));
+			else
+				skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
 			if (unlikely(!skb))
 				return 0;
 			vlan_set_tci(skb, 0);
+			vlan_set_qinq_tci(skb, 0);
 		}
 	}
 
diff --git a/datapath/vport.h b/datapath/vport.h
index 019ce57..1538420 100644
--- a/datapath/vport.h
+++ b/datapath/vport.h
@@ -249,11 +249,12 @@ static inline struct vport *vport_from_priv(const void *priv)
 
 void ovs_vport_receive(struct vport *, struct sk_buff *);
 void ovs_vport_record_error(struct vport *, enum vport_err_type err_type);
-void check_vlan_mpls_hlen(struct sk_buff *skb, unsigned int *vlan_hlen,
-			  unsigned int *mpls_hlen);
+void check_vlan_qinq_mpls_hlen(struct sk_buff *skb, unsigned int *vlan_hlen,
+				unsigned int *mpls_hlen);
 void check_mpls_hlen(struct sk_buff *skb, unsigned int *mpls_hlen);
-void check_skb_vlan_mpls_protocol(struct sk_buff *skb);
+void check_skb_vlan_qinq_mpls_protocol(struct sk_buff *skb);
 bool mpls_tag_present(struct sk_buff *skb);
+bool vlan_qinq_tag_present(struct sk_buff *skb);
 u8 mpls_lse_to_tc(__be32 mpls_lse);
 u8 mpls_lse_to_ttl(__be32 mpls_lse);
 
diff --git a/include/linux/openvswitch.h b/include/linux/openvswitch.h
index 63436c7..5e7423d 100644
--- a/include/linux/openvswitch.h
+++ b/include/linux/openvswitch.h
@@ -279,6 +279,7 @@ enum ovs_key_attr {
 	OVS_KEY_ATTR_ARP,       /* struct ovs_key_arp */
 	OVS_KEY_ATTR_ND,        /* struct ovs_key_nd */
 	OVS_KEY_ATTR_MPLS,      /* be32 MPLS Label Stack Entry */
+	OVS_KEY_ATTR_VLAN_QINQ,	/* be16 VLAN QINQ TCI */
 	OVS_KEY_ATTR_TUN_ID = 63, /* be64 tunnel ID */
 	__OVS_KEY_ATTR_MAX
 };
@@ -443,13 +444,13 @@ enum ovs_userspace_attr {
  * @vlan_tci: Tag control identifier (TCI) to push.  The CFI bit must be set
  * (but it will not be set in the 802.1Q header that is pushed).
  *
- * The @vlan_tpid value is typically %ETH_P_8021Q.  The only acceptable TPID
- * values are those that the kernel module also parses as 802.1Q headers, to
- * prevent %OVS_ACTION_ATTR_PUSH_VLAN followed by %OVS_ACTION_ATTR_POP_VLAN
- * from having surprising results.
+ * The @vlan_tpid value is typically %ETH_P_8021Q or %ETH_P_8021AD.
+ * The only acceptable TPID values are those that the kernel module also
+ * parses as 802.1Q or 802.1AD headers, to prevent %OVS_ACTION_ATTR_PUSH_VLAN
+ * followed by %OVS_ACTION_ATTR_POP_VLAN from having surprising results.
  */
 struct ovs_action_push_vlan {
-	__be16 vlan_tpid;	/* 802.1Q TPID. */
+	__be16 vlan_tpid;	/* 802.1Q or 802.1AD TPID. */
 	__be16 vlan_tci;	/* 802.1Q TCI (VLAN ID and priority). */
 };
 
diff --git a/include/openflow/nicira-ext.h b/include/openflow/nicira-ext.h
index 46b831a..d74f43b 100644
--- a/include/openflow/nicira-ext.h
+++ b/include/openflow/nicira-ext.h
@@ -346,6 +346,7 @@ enum nx_action_subtype {
     NXAST_DEC_MPLS_TTL,         /* struct nx_action_header */
     NXAST_PUSH_MPLS,            /* struct nx_action_push_mpls */
     NXAST_POP_MPLS,             /* struct nx_action_pop_mpls */
+    NXAST_PUSH_VLAN,            /* struct nx_action_push_vlan */
 };
 
 /* Header for Nicira-defined actions. */
@@ -1797,6 +1798,42 @@ OFP_ASSERT(sizeof(struct nx_action_output_reg) == 24);
  * Masking: Not maskable. */
 #define NXM_NX_MPLS_STACK   NXM_HEADER  (0x0001, 33, 1)
 
+/* The vlan_tpid in VLAN QinQ header.
+ *
+ * Prereqs: None
+ *
+ * Format: 16-bit integer
+ *
+ * Masking: Not maskable. */
+#define NXM_NX_VLAN_TPID    NXM_HEADER  (0x0001, 34, 2)
+
+/* The vlan_qinq_tci in VLAN QinQ header.
+ *
+ * Prereqs: None
+ *
+ * Format: 16-bit integer
+ *
+ * Masking: Not maskable. */
+#define NXM_NX_VLAN_QINQ_TCI      NXM_HEADER  (0x0001, 35, 2)
+
+/* The vlan_qinq_vid in VLAN QinQ header.
+ *
+ * Prereqs: None
+ *
+ * Format: 16-bit integer, lower 12 bits
+ *
+ * Masking: Not maskable. */
+#define NXM_NX_VLAN_QINQ_VID      NXM_HEADER  (0x0001, 36, 2)
+
+/* The vlan_qinq_pcp in VLAN QinQ header.
+ *
+ * Prereqs: None
+ *
+ * Format: 8-bit integer, lower 3 bits
+ *
+ * Masking: Not maskable. */
+#define NXM_NX_VLAN_QINQ_PCP      NXM_HEADER  (0x0001, 37, 1)
+
 /* ## --------------------- ## */
 /* ## Requests and replies. ## */
 /* ## --------------------- ## */
@@ -2065,4 +2102,15 @@ struct nx_action_pop_mpls {
 };
 OFP_ASSERT(sizeof(struct nx_action_pop_mpls) == 16);
 
+/* Action structure for NXAST_PUSH_VLAN. */
+struct nx_action_push_vlan {
+    ovs_be16 type;                  /* OFPAT_PUSH_MPLS. */
+    ovs_be16 len;                   /* Length is 8. */
+    ovs_be32 vendor;                /* NX_VENDOR_ID. */
+    ovs_be16 subtype;               /* NXAST_PUSH_VLAN */
+    ovs_be16 tpid;                  /* VLAN tpid */
+    uint8_t  pad[4];
+};
+OFP_ASSERT(sizeof(struct nx_action_push_vlan) == 16);
+
 #endif /* openflow/nicira-ext.h */
diff --git a/lib/bond.c b/lib/bond.c
index 54f2d0e..0724d1c 100644
--- a/lib/bond.c
+++ b/lib/bond.c
@@ -533,7 +533,7 @@ bond_compose_learning_packet(struct bond *bond,
     packet = ofpbuf_new(0);
     compose_rarp(packet, eth_src);
     if (vlan) {
-        eth_push_vlan(packet, htons(vlan));
+        eth_push_vlan(packet, htons(vlan), htons(ETH_TYPE_VLAN));
     }
 
     *port_aux = slave->aux;
diff --git a/lib/cfm.c b/lib/cfm.c
index 41a27a0..d7c2753 100644
--- a/lib/cfm.c
+++ b/lib/cfm.c
@@ -434,7 +434,7 @@ cfm_compose_ccm(struct cfm *cfm, struct ofpbuf *packet,
 
     if (ccm_vlan || cfm->ccm_pcp) {
         uint16_t tci = ccm_vlan | (cfm->ccm_pcp << VLAN_PCP_SHIFT);
-        eth_push_vlan(packet, htons(tci));
+        eth_push_vlan(packet, htons(tci), htons(ETH_TYPE_VLAN));
     }
 
     ccm = packet->l3;
diff --git a/lib/classifier.c b/lib/classifier.c
index d3cb9c0..b810f84 100644
--- a/lib/classifier.c
+++ b/lib/classifier.c
@@ -263,6 +263,33 @@ cls_rule_set_dl_vlan_pcp(struct cls_rule *rule, uint8_t dl_vlan_pcp)
     rule->wc.vlan_tci_mask |= htons(VLAN_CFI | VLAN_PCP_MASK);
 }
 
+/* Modifies 'rule' so that it matches only packets with an outer tag of
+ * 802.1Q or 8021AD header. */
+void
+cls_rule_set_dl_vlan_tpid(struct cls_rule *rule, ovs_be16 dl_vlan_tpid)
+{
+    rule->wc.wildcards &= ~FWW_VLAN_TPID;
+    flow_set_vlan_tpid(&rule->flow, dl_vlan_tpid);
+}
+
+/* Modifies 'rule' to match only packets with an 802.1Q header whose
+ * VID equals the low 12 bits of 'dl_vlan_vid'. */
+void
+cls_rule_set_dl_vlan_qinq_vid(struct cls_rule *rule, ovs_be16 dl_vlan_qinq_vid)
+{
+    rule->wc.wildcards &= ~FWW_VLAN_QINQ_VID;
+    flow_set_vlan_qinq_vid(&rule->flow, dl_vlan_qinq_vid);
+}
+
+/* Modifies 'rule' to match only packets with an 802.1Q header whose
+ * PCP equals the low 3 bits of 'dl_vlan_pcp'. */
+void
+cls_rule_set_dl_vlan_qinq_pcp(struct cls_rule *rule, uint8_t dl_vlan_qinq_pcp)
+{
+    rule->wc.wildcards &= ~FWW_VLAN_QINQ_PCP;
+    flow_set_vlan_qinq_pcp(&rule->flow, dl_vlan_qinq_pcp);
+}
+
 /* Modifies 'rule' depending on 'mpls_label':
  * Makes 'rule' match only packets with an MPLS header whose label equals the
  * low 20 bits of 'mpls_label'. */
@@ -554,7 +581,7 @@ cls_rule_format(const struct cls_rule *rule, struct ds *s)
 
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     if (rule->priority != OFP_DEFAULT_PRIORITY) {
         ds_put_format(s, "priority=%d,", rule->priority);
@@ -655,6 +682,17 @@ cls_rule_format(const struct cls_rule *rule, struct ds *s)
                           ntohs(f->vlan_tci), ntohs(wc->vlan_tci_mask));
         }
     }
+    if (!(w & FWW_VLAN_TPID)) {
+        ds_put_format(s, "dl_vlan_tpid=0x%"PRIx16",", ntohs(f->vlan_tpid));
+    }
+    if (!(w & FWW_VLAN_QINQ_VID)) {
+        ds_put_format(s, "dl_vlan_qinq_vid=%"PRIu16",",
+                 vlan_tci_to_vid(f->vlan_qinq_tci));
+    }
+    if (!(w & FWW_VLAN_QINQ_PCP)) {
+        ds_put_format(s, "dl_vlan_qinq_pcp=%d,",
+                 vlan_tci_to_pcp(f->vlan_qinq_tci));
+    }
     format_eth_masked(s, "dl_src", f->dl_src, wc->dl_src_mask);
     format_eth_masked(s, "dl_dst", f->dl_dst, wc->dl_dst_mask);
     if (!skip_type && !(w & FWW_DL_TYPE)) {
@@ -1233,7 +1271,7 @@ flow_equal_except(const struct flow *a, const struct flow *b,
     const flow_wildcards_t wc = wildcards->wildcards;
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     for (i = 0; i < FLOW_N_REGS; i++) {
         if ((a->regs[i] ^ b->regs[i]) & wildcards->reg_masks[i]) {
@@ -1267,6 +1305,11 @@ flow_equal_except(const struct flow *a, const struct flow *b,
                 !((a->mpls_lse ^ b->mpls_lse) & htonl(MPLS_TC_MASK)))
             && (wc & FWW_MPLS_STACK ||
                 !((a->mpls_lse ^ b->mpls_lse) & htonl(MPLS_STACK_MASK)))
+            && (wc & FWW_VLAN_TPID || a->vlan_tpid == b->vlan_tpid)
+            && (wc & FWW_VLAN_QINQ_VID ||
+                !((a->vlan_qinq_tci ^ b->vlan_qinq_tci) & htons(VLAN_VID_MASK)))
+            && (wc & FWW_VLAN_QINQ_PCP ||
+                !((a->vlan_qinq_tci ^ b->vlan_qinq_tci) & htons(VLAN_PCP_MASK)))
             && ipv6_equal_except(&a->ipv6_src, &b->ipv6_src,
                     &wildcards->ipv6_src_mask)
             && ipv6_equal_except(&a->ipv6_dst, &b->ipv6_dst,
diff --git a/lib/classifier.h b/lib/classifier.h
index 9a38d63..7aca7db 100644
--- a/lib/classifier.h
+++ b/lib/classifier.h
@@ -108,6 +108,9 @@ void cls_rule_set_any_vid(struct cls_rule *);
 void cls_rule_set_dl_vlan(struct cls_rule *, ovs_be16);
 void cls_rule_set_any_pcp(struct cls_rule *);
 void cls_rule_set_dl_vlan_pcp(struct cls_rule *, uint8_t);
+void cls_rule_set_dl_vlan_tpid(struct cls_rule *, ovs_be16);
+void cls_rule_set_dl_vlan_qinq_vid(struct cls_rule *, ovs_be16);
+void cls_rule_set_dl_vlan_qinq_pcp(struct cls_rule *, uint8_t);
 void cls_rule_set_mpls_label(struct cls_rule *, ovs_be32);
 void cls_rule_set_mpls_tc(struct cls_rule *, uint8_t);
 void cls_rule_set_mpls_stack(struct cls_rule *, uint8_t);
diff --git a/lib/dpif-netdev.c b/lib/dpif-netdev.c
index a07e0d4..bb723b8 100644
--- a/lib/dpif-netdev.c
+++ b/lib/dpif-netdev.c
@@ -1194,6 +1194,7 @@ execute_set_action(struct ofpbuf *packet, const struct nlattr *a)
      case OVS_KEY_ATTR_ETHERTYPE:
      case OVS_KEY_ATTR_IN_PORT:
      case OVS_KEY_ATTR_VLAN:
+     case OVS_KEY_ATTR_VLAN_QINQ:
      case OVS_KEY_ATTR_MPLS:
      case OVS_KEY_ATTR_ICMP:
      case OVS_KEY_ATTR_ICMPV6:
@@ -1229,7 +1230,7 @@ dp_netdev_execute_actions(struct dp_netdev *dp,
 
         case OVS_ACTION_ATTR_PUSH_VLAN:
             vlan = nl_attr_get(a);
-            eth_push_vlan(packet, vlan->vlan_tci);
+            eth_push_vlan(packet, vlan->vlan_tci, vlan->vlan_tpid);
             break;
 
         case OVS_ACTION_ATTR_POP_VLAN:
diff --git a/lib/flow.c b/lib/flow.c
index 4f4a04b..ae3940b 100644
--- a/lib/flow.c
+++ b/lib/flow.c
@@ -110,16 +110,48 @@ parse_mpls(struct ofpbuf *b, struct flow *flow)
 }
 
 static void
-parse_vlan(struct ofpbuf *b, struct flow *flow)
+parse_remaining_vlans(struct ofpbuf *b)
 {
     struct qtag_prefix {
         ovs_be16 eth_type;      /* ETH_TYPE_VLAN */
         ovs_be16 tci;
     };
+    ovs_be16 ethtype = *((ovs_be16 *)b->data);
+
+    while ((ethtype == htons(ETH_TYPE_VLAN) ||
+            ethtype == htons(ETH_TYPE_VLAN_8021AD)) &&
+           (b->size >= sizeof(struct qtag_prefix) + sizeof(ovs_be16))) {
+        struct qtag_prefix *qp = ofpbuf_pull(b, sizeof *qp);
+        ethtype = qp->eth_type;
+    }
+}
+
+static void
+parse_vlan(struct ofpbuf *b, struct flow *flow)
+{
+    struct qtag_prefix {
+        ovs_be16 eth_type;      /* ETH_TYPE_VLAN or ETH_TYPE_VLAN_8021ad */
+        ovs_be16 tci;
+    };
 
     if (b->size >= sizeof(struct qtag_prefix) + sizeof(ovs_be16)) {
         struct qtag_prefix *qp = ofpbuf_pull(b, sizeof *qp);
         flow->vlan_tci = qp->tci | htons(VLAN_CFI);
+        flow->vlan_tpid = qp->eth_type;
+    }
+}
+
+static void
+parse_vlan_qinq(struct ofpbuf *b, struct flow *flow)
+{
+    struct qtag_prefix {
+        ovs_be16 eth_type;      /* ETH_TYPE_VLAN */
+        ovs_be16 tci;
+    };
+
+    if (b->size >= sizeof(struct qtag_prefix) + sizeof(ovs_be16)) {
+        struct qtag_prefix *qp = ofpbuf_pull(b, sizeof *qp);
+        flow->vlan_qinq_tci = qp->tci | htons(VLAN_CFI);
     }
 }
 
@@ -383,8 +415,17 @@ flow_extract(struct ofpbuf *packet, uint32_t skb_priority, ovs_be64 tun_id,
 
     /* dl_type, vlan_tci. */
     ofpbuf_pull(&b, ETH_ADDR_LEN * 2);
-    if (eth->eth_type == htons(ETH_TYPE_VLAN)) {
+    if (eth->eth_type == htons(ETH_TYPE_VLAN) ||
+        eth->eth_type == htons(ETH_TYPE_VLAN_8021AD)) {
+        ovs_be16 next_ethtype;
         parse_vlan(&b, flow);
+        /* Parse next vlan tag and skip over any other vlan tags. */
+        next_ethtype = *((ovs_be16 *)b.data);
+        if (next_ethtype == htons(ETH_TYPE_VLAN) ||
+            next_ethtype == htons(ETH_TYPE_VLAN_8021AD)) {
+            parse_vlan_qinq(&b, flow);
+            parse_remaining_vlans(&b);
+        }
     }
 
     flow->dl_type = parse_ethertype(&b);
@@ -478,7 +519,7 @@ flow_zero_wildcards(struct flow *flow, const struct flow_wildcards *wildcards)
     const flow_wildcards_t wc = wildcards->wildcards;
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     for (i = 0; i < FLOW_N_REGS; i++) {
         flow->regs[i] &= wildcards->reg_masks[i];
@@ -522,6 +563,16 @@ flow_zero_wildcards(struct flow *flow, const struct flow_wildcards *wildcards)
     if (wc & FWW_MPLS_STACK) {
         flow->mpls_lse &= ~htonl(MPLS_STACK_MASK);
     }
+    if (wc & FWW_VLAN_TPID) {
+        flow->vlan_tpid = 0;
+    }
+    flow->vlan_qinq_tci &= ~htons(VLAN_CFI);
+    if (wc & FWW_VLAN_QINQ_VID) {
+        flow->vlan_qinq_tci &= ~htons(VLAN_VID_MASK);
+    }
+    if (wc & FWW_VLAN_QINQ_PCP) {
+        flow->vlan_qinq_tci &= ~htons(VLAN_PCP_MASK);
+    }
     flow->nw_frag &= wildcards->nw_frag_mask;
     if (wc & FWW_ARP_SHA) {
         memset(flow->arp_sha, 0, sizeof flow->arp_sha);
@@ -542,7 +593,7 @@ flow_zero_wildcards(struct flow *flow, const struct flow_wildcards *wildcards)
 void
 flow_get_metadata(const struct flow *flow, struct flow_metadata *fmd)
 {
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     fmd->tun_id = flow->tun_id;
     fmd->tun_id_mask = htonll(UINT64_MAX);
@@ -579,6 +630,14 @@ flow_format(struct ds *ds, const struct flow *flow)
     } else {
         ds_put_char(ds, '0');
     }
+    ds_put_format(ds, "),qinq_tci(");
+    if (flow->vlan_qinq_tci) {
+        ds_put_format(ds, "vlan:%"PRIu16",pcp:%d",
+                      vlan_tci_to_vid(flow->vlan_qinq_tci),
+                      vlan_tci_to_pcp(flow->vlan_qinq_tci));
+    } else {
+        ds_put_char(ds, '0');
+    }
     ds_put_format(ds, ") mac("ETH_ADDR_FMT"->"ETH_ADDR_FMT
                       ") type:%04"PRIx16,
                   ETH_ADDR_ARGS(flow->dl_src),
@@ -643,7 +702,7 @@ flow_print(FILE *stream, const struct flow *flow)
 void
 flow_wildcards_init_catchall(struct flow_wildcards *wc)
 {
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     wc->wildcards = FWW_ALL;
     wc->tun_id_mask = htonll(0);
@@ -667,7 +726,7 @@ flow_wildcards_init_catchall(struct flow_wildcards *wc)
 void
 flow_wildcards_init_exact(struct flow_wildcards *wc)
 {
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     wc->wildcards = 0;
     wc->tun_id_mask = htonll(UINT64_MAX);
@@ -693,7 +752,7 @@ flow_wildcards_is_exact(const struct flow_wildcards *wc)
 {
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     if (wc->wildcards
         || wc->tun_id_mask != htonll(UINT64_MAX)
@@ -727,7 +786,7 @@ flow_wildcards_is_catchall(const struct flow_wildcards *wc)
 {
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     if (wc->wildcards != FWW_ALL
         || wc->tun_id_mask != htonll(0)
@@ -764,7 +823,7 @@ flow_wildcards_combine(struct flow_wildcards *dst,
 {
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     dst->wildcards = src1->wildcards | src2->wildcards;
     dst->tun_id_mask = src1->tun_id_mask & src2->tun_id_mask;
@@ -805,7 +864,7 @@ flow_wildcards_equal(const struct flow_wildcards *a,
 {
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     if (a->wildcards != b->wildcards
         || a->tun_id_mask != b->tun_id_mask
@@ -841,7 +900,7 @@ flow_wildcards_has_extra(const struct flow_wildcards *a,
     uint8_t eth_masked[ETH_ADDR_LEN];
     struct in6_addr ipv6_masked;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     for (i = 0; i < FLOW_N_REGS; i++) {
         if ((a->reg_masks[i] & b->reg_masks[i]) != b->reg_masks[i]) {
@@ -902,6 +961,7 @@ flow_hash_symmetric_l4(const struct flow *flow, uint32_t basis)
         };
         ovs_be16 eth_type;
         ovs_be16 vlan_tci;
+        ovs_be16 vlan_qinq_tci;
         ovs_be16 tp_port;
         uint8_t eth_addr[ETH_ADDR_LEN];
         uint8_t ip_proto;
@@ -914,6 +974,7 @@ flow_hash_symmetric_l4(const struct flow *flow, uint32_t basis)
         fields.eth_addr[i] = flow->dl_src[i] ^ flow->dl_dst[i];
     }
     fields.vlan_tci = flow->vlan_tci & htons(VLAN_VID_MASK);
+    fields.vlan_qinq_tci = flow->vlan_qinq_tci & htons(VLAN_VID_MASK);
     fields.eth_type = flow->dl_type;
 
     /* UDP source and destination port are not taken into account because they
@@ -1014,6 +1075,38 @@ flow_set_vlan_pcp(struct flow *flow, uint8_t pcp)
     flow->vlan_tci |= htons((pcp << VLAN_PCP_SHIFT) | VLAN_CFI);
 }
 
+/* Sets the VLAN tpid (outer tag) tpid that 'flow' matches. */
+void
+flow_set_vlan_tpid(struct flow *flow, ovs_be16 vlan_tpid)
+{
+    flow->vlan_tpid = vlan_tpid;
+}
+
+/* Sets the VLAN QinQ VID that 'flow' matches to 'vid'
+ * If it is in the range 0...4095, 'flow->vlan_tci' is set to match
+ * that VLAN.  Any existing PCP match is unchanged. */
+void
+flow_set_vlan_qinq_vid(struct flow *flow, ovs_be16 qinq_vid)
+{
+    if (qinq_vid == htons(OFP_VLAN_NONE)) {
+        flow->vlan_qinq_tci = htons(0);
+    } else {
+        qinq_vid &= htons(VLAN_VID_MASK);
+        flow->vlan_qinq_tci &= ~htons(VLAN_VID_MASK);
+        flow->vlan_qinq_tci |= qinq_vid;
+    }
+}
+
+/* Sets the VLAN PCP that 'flow' matches to 'pcp', which should be in the
+ * range 0...7. */
+void
+flow_set_vlan_qinq_pcp(struct flow *flow, uint8_t qinq_pcp)
+{
+    qinq_pcp &= 0x07;
+    flow->vlan_qinq_tci &= ~htons(VLAN_PCP_MASK);
+    flow->vlan_qinq_tci |= htons((qinq_pcp << VLAN_PCP_SHIFT));
+}
+
 /* Sets the MPLS Label that 'flow' matches to 'label', which is interpreted
  * as an OpenFlow 1.1 "mpls_label" value. */
 void
@@ -1064,7 +1157,11 @@ flow_compose(struct ofpbuf *b, const struct flow *flow)
     }
 
     if (flow->vlan_tci & htons(VLAN_CFI)) {
-        eth_push_vlan(b, flow->vlan_tci);
+        eth_push_vlan(b, flow->vlan_tci, flow->vlan_tpid);
+    }
+
+    if (flow->vlan_qinq_tci & htons(VLAN_CFI)) {
+        eth_push_vlan(b, flow->vlan_qinq_tci, htons(ETH_TYPE_VLAN));
     }
 
     if (flow->dl_type == htons(ETH_TYPE_MPLS) ||
diff --git a/lib/flow.h b/lib/flow.h
index 328938c..590f08b 100644
--- a/lib/flow.h
+++ b/lib/flow.h
@@ -34,7 +34,7 @@ struct ofpbuf;
 /* This sequence number should be incremented whenever anything involving flows
  * or the wildcarding of flows changes.  This will cause build assertion
  * failures in places which likely need to be updated. */
-#define FLOW_WC_SEQ 12
+#define FLOW_WC_SEQ 13
 
 #define FLOW_N_REGS 8
 BUILD_ASSERT_DECL(FLOW_N_REGS <= NXM_NX_MAX_REGS);
@@ -64,6 +64,8 @@ struct flow {
     ovs_be32 mpls_lse;          /* MPLS label stack entry. */
     uint16_t in_port;           /* OpenFlow port number of input port. */
     ovs_be16 vlan_tci;          /* If 802.1Q, TCI | VLAN_CFI; otherwise 0. */
+    ovs_be16 vlan_tpid;         /* If vlan qinq, TPID = outer tpid. */
+    ovs_be16 vlan_qinq_tci;     /* If vlan qinq, qinq TCI | VLAN_CFI. */
     ovs_be16 dl_type;           /* Ethernet frame type. */
     ovs_be16 tp_src;            /* TCP/UDP source port. */
     ovs_be16 tp_dst;            /* TCP/UDP destination port. */
@@ -75,7 +77,7 @@ struct flow {
     uint8_t arp_tha[6];         /* ARP/ND target hardware address. */
     uint8_t nw_ttl;             /* IP TTL/Hop Limit. */
     uint8_t nw_frag;            /* FLOW_FRAG_* flags. */
-    uint8_t reserved[6];        /* Reserved for 64-bit packing. */
+    uint8_t reserved[2];        /* Reserved for 64-bit packing. */
 };
 
 /* Represents the metadata fields of struct flow.  The masks are used to
@@ -93,14 +95,14 @@ struct flow_metadata {
 
 /* Assert that there are FLOW_SIG_SIZE bytes of significant data in "struct
  * flow", followed by FLOW_PAD_SIZE bytes of padding. */
-#define FLOW_SIG_SIZE (114 + FLOW_N_REGS * 4)
-#define FLOW_PAD_SIZE 6
+#define FLOW_SIG_SIZE (118 + FLOW_N_REGS * 4)
+#define FLOW_PAD_SIZE 2
 BUILD_ASSERT_DECL(offsetof(struct flow, nw_frag) == FLOW_SIG_SIZE - 1);
 BUILD_ASSERT_DECL(sizeof(((struct flow *)0)->nw_frag) == 1);
 BUILD_ASSERT_DECL(sizeof(struct flow) == FLOW_SIG_SIZE + FLOW_PAD_SIZE);
 
 /* Remember to update FLOW_WC_SEQ when changing 'struct flow'. */
-BUILD_ASSERT_DECL(FLOW_SIG_SIZE == 146 && FLOW_WC_SEQ == 12);
+BUILD_ASSERT_DECL(FLOW_SIG_SIZE == 150 && FLOW_WC_SEQ == 13);
 
 void flow_extract(struct ofpbuf *, uint32_t priority, ovs_be64 tun_id,
                   uint16_t in_port, struct flow *);
@@ -116,6 +118,9 @@ static inline size_t flow_hash(const struct flow *, uint32_t basis);
 
 void flow_set_vlan_vid(struct flow *, ovs_be16 vid);
 void flow_set_vlan_pcp(struct flow *, uint8_t pcp);
+void flow_set_vlan_tpid(struct flow *, ovs_be16 vlan_tpid);
+void flow_set_vlan_qinq_vid(struct flow *, ovs_be16 qinq_vid);
+void flow_set_vlan_qinq_pcp(struct flow *, uint8_t qinq_pcp);
 
 void flow_set_mpls_label(struct flow *flow, ovs_be32 label);
 void flow_set_mpls_tc(struct flow *flow, uint8_t tc);
@@ -163,10 +168,13 @@ typedef unsigned int OVS_BITWISE flow_wildcards_t;
 #define FWW_MPLS_LABEL  ((OVS_FORCE flow_wildcards_t) (1 << 9))
 #define FWW_MPLS_TC     ((OVS_FORCE flow_wildcards_t) (1 << 10))
 #define FWW_MPLS_STACK  ((OVS_FORCE flow_wildcards_t) (1 << 11))
-#define FWW_ALL         ((OVS_FORCE flow_wildcards_t) (((1 << 12)) - 1))
+#define FWW_VLAN_TPID       ((OVS_FORCE flow_wildcards_t) (1 << 12))
+#define FWW_VLAN_QINQ_VID   ((OVS_FORCE flow_wildcards_t) (1 << 13))
+#define FWW_VLAN_QINQ_PCP   ((OVS_FORCE flow_wildcards_t) (1 << 14))
+#define FWW_ALL         ((OVS_FORCE flow_wildcards_t) (((1 << 15)) - 1))
 
 /* Remember to update FLOW_WC_SEQ when adding or removing FWW_*. */
-BUILD_ASSERT_DECL(FWW_ALL == ((1 << 12) - 1) && FLOW_WC_SEQ == 12);
+BUILD_ASSERT_DECL(FWW_ALL == ((1 << 15) - 1) && FLOW_WC_SEQ == 13);
 
 /* Information on wildcards for a flow, as a supplement to "struct flow".
  *
@@ -192,7 +200,7 @@ struct flow_wildcards {
 };
 
 /* Remember to update FLOW_WC_SEQ when updating struct flow_wildcards. */
-BUILD_ASSERT_DECL(sizeof(struct flow_wildcards) == 120 && FLOW_WC_SEQ == 12);
+BUILD_ASSERT_DECL(sizeof(struct flow_wildcards) == 120 && FLOW_WC_SEQ == 13);
 
 void flow_wildcards_init_catchall(struct flow_wildcards *);
 void flow_wildcards_init_exact(struct flow_wildcards *);
diff --git a/lib/learn.c b/lib/learn.c
index 5478b74..e61f8fa 100644
--- a/lib/learn.c
+++ b/lib/learn.c
@@ -184,7 +184,7 @@ learn_check(const struct nx_action_learn *learn, const struct flow *flow)
                      * prerequisites.  No prerequisite depends on the value of
                      * a field that is wider than 64 bits.  So just skip
                      * setting it entirely. */
-                    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+                    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
                 }
             }
         }
diff --git a/lib/meta-flow.c b/lib/meta-flow.c
index f92b46b..c2f4bad 100644
--- a/lib/meta-flow.c
+++ b/lib/meta-flow.c
@@ -169,6 +169,38 @@ static const struct mf_field mf_fields[MFF_N_IDS] = {
     },
 
     /* ## ---- ## */
+    /* ## QinQ ## */
+    /* ## ---- ## */
+    {
+        MFF_VLAN_TPID, "dl_vlan_tpid", NULL,
+        MF_FIELD_SIZES(be16),
+        MFM_NONE, FWW_VLAN_TPID,
+        MFS_HEXADECIMAL,
+        MFP_NONE,
+        true,
+        NXM_NX_VLAN_TPID, "NXM_NX_VLAN_TPID",
+        0, NULL,
+    }, {
+        MFF_VLAN_QINQ_VID, "dl_vlan_qinq_vid", NULL,
+        sizeof(ovs_be16), 12,
+        MFM_NONE, FWW_VLAN_QINQ_VID,
+        MFS_DECIMAL,
+        MFP_VLAN_TPID,
+        true,
+        NXM_NX_VLAN_QINQ_VID, "NXM_NX_VLAN_QINQ_VID",
+        0, NULL,
+    }, {
+        MFF_VLAN_QINQ_PCP, "dl_vlan_qinq_pcp", NULL,
+        1, 3,
+        MFM_NONE, FWW_VLAN_QINQ_PCP,
+        MFS_DECIMAL,
+        MFP_VLAN_TPID,
+        true,
+        NXM_NX_VLAN_QINQ_PCP, "NXM_NX_VLAN_QINQ_PCP",
+        0, NULL,
+    },
+
+    /* ## ---- ## */
     /* ## L2.5 ## */
     /* ## ---- ## */
     {
@@ -620,6 +652,9 @@ mf_is_all_wild(const struct mf_field *mf, const struct flow_wildcards *wc)
     case MFF_MPLS_LABEL:
     case MFF_MPLS_TC:
     case MFF_MPLS_STACK:
+    case MFF_VLAN_TPID:
+    case MFF_VLAN_QINQ_VID:
+    case MFF_VLAN_QINQ_PCP:
         assert(mf->fww_bit != 0);
         return (wc->wildcards & mf->fww_bit) != 0;
 
@@ -731,6 +766,9 @@ mf_get_mask(const struct mf_field *mf, const struct flow_wildcards *wc,
     case MFF_MPLS_LABEL:
     case MFF_MPLS_TC:
     case MFF_MPLS_STACK:
+    case MFF_VLAN_TPID:
+    case MFF_VLAN_QINQ_VID:
+    case MFF_VLAN_QINQ_PCP:
         assert(mf->fww_bit != 0);
         memset(mask, wc->wildcards & mf->fww_bit ? 0x00 : 0xff, mf->n_bytes);
         break;
@@ -892,6 +930,9 @@ mf_are_prereqs_ok(const struct mf_field *mf, const struct flow *flow)
         return flow->dl_type == htons(ETH_TYPE_IP);
     case MFP_IPV6:
         return flow->dl_type == htons(ETH_TYPE_IPV6);
+    case MFP_VLAN_TPID:
+        return (flow->vlan_tpid == htons(ETH_TYPE_VLAN) ||
+                flow->vlan_tpid == htons(ETH_TYPE_VLAN_8021AD));
     case MFP_MPLS:
         return (flow->dl_type == htons(ETH_TYPE_MPLS) ||
                 flow->dl_type == htons(ETH_TYPE_MPLS_MCAST));
@@ -1014,6 +1055,15 @@ mf_is_value_valid(const struct mf_field *mf, const union mf_value *value)
     case MFF_IPV6_LABEL:
         return !(value->be32 & ~htonl(IPV6_LABEL_MASK));
 
+    case MFF_VLAN_TPID:
+        return !(value->be16 & htons(0));
+
+    case MFF_VLAN_QINQ_VID:
+        return !(value->be16 & htons(VLAN_CFI | VLAN_PCP_MASK));
+
+    case MFF_VLAN_QINQ_PCP:
+        return !(value->u8 & ~7);
+
     case MFF_MPLS_LABEL:
         return !(value->be32 & ~htonl(MPLS_LABEL_MASK >> MPLS_LABEL_SHIFT));
 
@@ -1098,6 +1148,18 @@ mf_get_value(const struct mf_field *mf, const struct flow *flow,
         value->u8 = vlan_tci_to_pcp(flow->vlan_tci);
         break;
 
+    case MFF_VLAN_TPID:
+        value->be16 = flow->vlan_tpid;
+        break;
+
+    case MFF_VLAN_QINQ_VID:
+        value->be16 = flow->vlan_qinq_tci & htons(VLAN_VID_MASK);
+        break;
+
+    case MFF_VLAN_QINQ_PCP:
+        value->u8 = vlan_tci_to_pcp(flow->vlan_qinq_tci);
+        break;
+
     case MFF_MPLS_LABEL:
         value->be32 = htonl(mpls_lse_to_label(flow->mpls_lse));
         break;
@@ -1316,6 +1378,18 @@ mf_set_value(const struct mf_field *mf,
         cls_rule_set_nw_ttl(rule, value->u8);
         break;
 
+    case MFF_VLAN_TPID:
+        cls_rule_set_dl_vlan_tpid(rule, value->be16);
+        break;
+
+    case MFF_VLAN_QINQ_VID:
+        cls_rule_set_dl_vlan_qinq_vid(rule, value->be16);
+        break;
+
+    case MFF_VLAN_QINQ_PCP:
+        cls_rule_set_dl_vlan_qinq_pcp(rule, value->u8);
+        break;
+
     case MFF_MPLS_LABEL:
         cls_rule_set_mpls_label(rule, value->be32);
         break;
@@ -1462,6 +1536,18 @@ mf_set_flow_value(const struct mf_field *mf,
         flow_set_vlan_pcp(flow, value->u8);
         break;
 
+    case MFF_VLAN_TPID:
+        flow_set_vlan_tpid(flow, value->be16);
+        break;
+
+    case MFF_VLAN_QINQ_VID:
+        flow_set_vlan_qinq_vid(flow, value->be16);
+        break;
+
+    case MFF_VLAN_QINQ_PCP:
+        flow_set_vlan_qinq_pcp(flow, value->u8);
+        break;
+
     case MFF_MPLS_LABEL:
         flow_set_mpls_label(flow, value->be32);
         break;
@@ -1714,6 +1800,21 @@ mf_set_wild(const struct mf_field *mf, struct cls_rule *rule)
         rule->flow.nw_ttl = 0;
         break;
 
+    case MFF_VLAN_TPID:
+        rule->wc.wildcards |= FWW_VLAN_TPID;
+        rule->flow.vlan_tpid = 0;
+        break;
+
+    case MFF_VLAN_QINQ_VID:
+        rule->wc.wildcards |= FWW_VLAN_QINQ_VID;
+        rule->flow.vlan_qinq_tci &= ~htons(VLAN_VID_MASK);
+        break;
+
+    case MFF_VLAN_QINQ_PCP:
+        rule->wc.wildcards |= FWW_VLAN_QINQ_PCP;
+        rule->flow.vlan_qinq_tci &= ~htons(VLAN_PCP_MASK);
+        break;
+
     case MFF_MPLS_LABEL:
         rule->wc.wildcards |= FWW_MPLS_LABEL;
         rule->flow.mpls_lse &= ~htonl(MPLS_LABEL_MASK);
@@ -1807,6 +1908,9 @@ mf_set(const struct mf_field *mf,
     case MFF_ETH_TYPE:
     case MFF_VLAN_VID:
     case MFF_VLAN_PCP:
+    case MFF_VLAN_TPID:
+    case MFF_VLAN_QINQ_VID:
+    case MFF_VLAN_QINQ_PCP:
     case MFF_IPV6_LABEL:
     case MFF_MPLS_LABEL:
     case MFF_MPLS_TC:
@@ -2071,6 +2175,18 @@ mf_random_value(const struct mf_field *mf, union mf_value *value)
         value->u8 &= 0x07;
         break;
 
+    case MFF_VLAN_TPID:
+        value->be16 &= htons(0xffff);
+        break;
+
+    case MFF_VLAN_QINQ_VID:
+        value->be16 &= htons(VLAN_VID_MASK);
+        break;
+
+    case MFF_VLAN_QINQ_PCP:
+        value->u8 &= 0x07;
+        break;
+
     case MFF_MPLS_LABEL:
         value->be32 &= htonl(MPLS_LABEL_MASK >> MPLS_LABEL_SHIFT);
         break;
diff --git a/lib/meta-flow.h b/lib/meta-flow.h
index c61f2c8..37de3ee 100644
--- a/lib/meta-flow.h
+++ b/lib/meta-flow.h
@@ -71,6 +71,11 @@ enum mf_field_id {
     MFF_VLAN_VID,               /* be16 */
     MFF_VLAN_PCP,               /* u8 */
 
+    /* QinQ */
+    MFF_VLAN_TPID,              /* be16 */
+    MFF_VLAN_QINQ_VID,          /* be16 */
+    MFF_VLAN_QINQ_PCP,          /* u8 */
+
     /* L2.5 */
     MFF_MPLS_LABEL,             /* be32 */
     MFF_MPLS_TC,                /* u8 */
@@ -127,6 +132,7 @@ enum mf_prereqs {
 
     /* L2 requirements. */
     MFP_ARP,
+    MFP_VLAN_TPID,
     MFP_MPLS,
     MFP_IPV4,
     MFP_IPV6,
@@ -181,6 +187,8 @@ struct mf_field {
      *
      *     - "dl_vlan" is 2 bytes but only 12 bits.
      *     - "dl_vlan_pcp" is 1 byte but only 3 bits.
+     *     - "dl_vlan_qinq_vid" is 2 bytes but only 12 bits.
+     *     - "dl_vlan_qinq_pcp" is 1 byte but only 3 bits.
      *     - "is_frag" is 1 byte but only 2 bits.
      *     - "ipv6_label" is 4 bytes but only 20 bits.
      *     - "mpls_label" is 4 bytes but only 20 bits.
diff --git a/lib/nx-match.c b/lib/nx-match.c
index 40fbb04..46a905b 100644
--- a/lib/nx-match.c
+++ b/lib/nx-match.c
@@ -487,7 +487,7 @@ nx_put_match(struct ofpbuf *b, bool oxm, const struct cls_rule *cr,
     int match_len;
     int i;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     /* Metadata. */
     if (!(wc & FWW_IN_PORT)) {
@@ -514,6 +514,20 @@ nx_put_match(struct ofpbuf *b, bool oxm, const struct cls_rule *cr,
      * XXX missing OXM support */
     nxm_put_16m(b, NXM_OF_VLAN_TCI, flow->vlan_tci, cr->wc.vlan_tci_mask);
 
+    /* 802.1AD */
+    if (!(wc & FWW_VLAN_TPID) &&
+       (flow->vlan_tpid == htons(ETH_TYPE_VLAN) ||
+        flow->vlan_tpid == htons(ETH_TYPE_VLAN_8021AD))) {
+        nxm_put_16(b, NXM_NX_VLAN_TPID, flow->vlan_tpid);
+        if (!(wc & FWW_VLAN_QINQ_PCP)) {
+            nxm_put_8(b, NXM_NX_VLAN_QINQ_PCP,
+                      vlan_tci_to_pcp(flow->vlan_qinq_tci));
+        }
+        if (!(wc & FWW_VLAN_QINQ_VID)) {
+            nxm_put_16(b, NXM_NX_VLAN_QINQ_VID,
+                 htons(vlan_tci_to_vid(flow->vlan_qinq_tci)));
+        }
+    }
 
     /* MPLS. */
     if (!(wc & FWW_DL_TYPE) &&
diff --git a/lib/nx-match.h b/lib/nx-match.h
index b8d194b..7be6dcd 100644
--- a/lib/nx-match.h
+++ b/lib/nx-match.h
@@ -90,7 +90,7 @@ void nxm_decode(struct mf_subfield *, ovs_be32 header, ovs_be16 ofs_nbits);
 void nxm_decode_discrete(struct mf_subfield *, ovs_be32 header,
                          ovs_be16 ofs, ovs_be16 n_bits);
 
-BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 /* Upper bound on the length of an nx_match.  The longest nx_match (an
  * IPV6 neighbor discovery message using 5 registers) would be:
  *
diff --git a/lib/odp-util.c b/lib/odp-util.c
index 2dfa32f..b8c01fb 100644
--- a/lib/odp-util.c
+++ b/lib/odp-util.c
@@ -103,6 +103,7 @@ ovs_key_attr_to_string(enum ovs_key_attr attr)
     case OVS_KEY_ATTR_IN_PORT: return "in_port";
     case OVS_KEY_ATTR_ETHERNET: return "eth";
     case OVS_KEY_ATTR_VLAN: return "vlan";
+    case OVS_KEY_ATTR_VLAN_QINQ: return "vlan_qinq";
     case OVS_KEY_ATTR_ETHERTYPE: return "eth_type";
     case OVS_KEY_ATTR_IPV4: return "ipv4";
     case OVS_KEY_ATTR_IPV6: return "ipv6";
@@ -333,9 +334,7 @@ format_odp_action(struct ds *ds, const struct nlattr *a)
     case OVS_ACTION_ATTR_PUSH_VLAN:
         vlan = nl_attr_get(a);
         ds_put_cstr(ds, "push_vlan(");
-        if (vlan->vlan_tpid != htons(ETH_TYPE_VLAN)) {
-            ds_put_format(ds, "tpid=0x%04"PRIx16",", ntohs(vlan->vlan_tpid));
-        }
+        ds_put_format(ds, "tpid=0x%04"PRIx16",", ntohs(vlan->vlan_tpid));
         format_vlan_tci(ds, vlan->vlan_tci);
         ds_put_char(ds, ')');
         break;
@@ -725,6 +724,7 @@ odp_flow_key_attr_len(uint16_t type)
     case OVS_KEY_ATTR_ARP: return sizeof(struct ovs_key_arp);
     case OVS_KEY_ATTR_ND: return sizeof(struct ovs_key_nd);
     case OVS_KEY_ATTR_MPLS: return sizeof(ovs_be32);
+    case OVS_KEY_ATTR_VLAN_QINQ: return sizeof(ovs_be16);
 
     case OVS_KEY_ATTR_UNSPEC:
     case __OVS_KEY_ATTR_MAX:
@@ -826,6 +826,12 @@ format_odp_key_attr(const struct nlattr *a, struct ds *ds)
         ds_put_char(ds, ')');
         break;
 
+    case OVS_KEY_ATTR_VLAN_QINQ:
+        ds_put_char(ds, '(');
+        format_vlan_tci(ds, nl_attr_get_be16(a));
+        ds_put_char(ds, ')');
+        break;
+
     case OVS_KEY_ATTR_MPLS:
         ds_put_char(ds, '(');
         format_mpls_lse(ds, nl_attr_get_be32(a));
@@ -1091,6 +1097,30 @@ parse_odp_key_attr(const char *s, const struct simap *port_names,
     }
 
     {
+        uint16_t vid;
+        int pcp;
+        int cfi;
+        int n = -1;
+
+        if ((sscanf(s, "vlan_qinq(vid=%"SCNi16",pcp=%i)%n", &vid, &pcp, &n) > 0
+             && n > 0)) {
+            nl_msg_put_be16(key, OVS_KEY_ATTR_VLAN_QINQ,
+                            htons((vid << VLAN_VID_SHIFT) |
+                                  (pcp << VLAN_PCP_SHIFT) |
+                                  VLAN_CFI));
+            return n;
+        } else if ((sscanf(s, "vlan_qinq(vid=%"SCNi16",pcp=%i,cfi=%i)%n",
+                           &vid, &pcp, &cfi, &n) > 0
+             && n > 0)) {
+            nl_msg_put_be16(key, OVS_KEY_ATTR_VLAN_QINQ,
+                            htons((vid << VLAN_VID_SHIFT) |
+                                  (pcp << VLAN_PCP_SHIFT) |
+                                  (cfi ? VLAN_CFI : 0)));
+            return n;
+        }
+    }
+
+    {
         int eth_type;
         int n = -1;
 
@@ -1406,9 +1436,17 @@ odp_flow_key_from_flow(struct ofpbuf *buf, const struct flow *flow)
     memcpy(eth_key->eth_src, flow->dl_src, ETH_ADDR_LEN);
     memcpy(eth_key->eth_dst, flow->dl_dst, ETH_ADDR_LEN);
 
-    if (flow->vlan_tci != htons(0) || flow->dl_type == htons(ETH_TYPE_VLAN)) {
-        nl_msg_put_be16(buf, OVS_KEY_ATTR_ETHERTYPE, htons(ETH_TYPE_VLAN));
-        nl_msg_put_be16(buf, OVS_KEY_ATTR_VLAN, flow->vlan_tci);
+    if (flow->vlan_tci != htons(0) ||
+        flow->dl_type == htons(ETH_TYPE_VLAN) ||
+        flow->vlan_qinq_tci != htons(0)) {
+        if (flow->vlan_qinq_tci != htons(0)) {
+            nl_msg_put_be16(buf, OVS_KEY_ATTR_ETHERTYPE, flow->vlan_tpid);
+            nl_msg_put_be16(buf, OVS_KEY_ATTR_VLAN, flow->vlan_tci);
+            nl_msg_put_be16(buf, OVS_KEY_ATTR_VLAN_QINQ, flow->vlan_qinq_tci);
+        } else {
+            nl_msg_put_be16(buf, OVS_KEY_ATTR_ETHERTYPE, htons(ETH_TYPE_VLAN));
+            nl_msg_put_be16(buf, OVS_KEY_ATTR_VLAN, flow->vlan_tci);
+        }
         encap = nl_msg_start_nested(buf, OVS_KEY_ATTR_ENCAP);
         if (flow->vlan_tci == htons(0)) {
             goto unencap;
@@ -1844,7 +1882,7 @@ parse_8021q_onward(const struct nlattr *attrs[OVS_KEY_ATTR_MAX + 1],
            ? attrs[OVS_KEY_ATTR_ENCAP] : NULL);
     enum odp_key_fitness encap_fitness;
     enum odp_key_fitness fitness;
-    ovs_be16 tci;
+    ovs_be16 tci = 0, qinq_tci = 0;
 
     /* Calulate fitness of outer attributes. */
     expected_attrs |= ((UINT64_C(1) << OVS_KEY_ATTR_VLAN) |
@@ -1869,9 +1907,32 @@ parse_8021q_onward(const struct nlattr *attrs[OVS_KEY_ATTR_MAX + 1],
         return ODP_FIT_ERROR;
     }
 
+    /* Get the VLAN QinQ TCI value. */
+    /* Calulate fitness of vlan qinq attribute. */
+    if (present_attrs & (UINT64_C(1) << OVS_KEY_ATTR_VLAN_QINQ)) {
+        expected_attrs |= (UINT64_C(1) << OVS_KEY_ATTR_VLAN_QINQ);
+        fitness = check_expectations(present_attrs, out_of_range_attr,
+                                 expected_attrs, key, key_len);
+
+        qinq_tci = nl_attr_get_be16(attrs[OVS_KEY_ATTR_VLAN_QINQ]);
+        if (qinq_tci == htons(0)) {
+            /* Corner case for a truncated 802.1Q header. */
+            if (fitness == ODP_FIT_PERFECT && nl_attr_get_size(encap)) {
+                return ODP_FIT_TOO_MUCH;
+            }
+            return fitness;
+        } else if (!(qinq_tci & htons(VLAN_CFI))) {
+            VLOG_ERR_RL(&rl, "OVS_KEY_ATTR_VLAN_QINQ 0x%04"PRIx16" is nonzero "
+                        "but CFI bit is not set", ntohs(qinq_tci));
+            return ODP_FIT_ERROR;
+        }
+        flow->vlan_qinq_tci = qinq_tci;
+    }
+
     /* Set vlan_tci.
      * Remove the TPID from dl_type since it's not the real Ethertype.  */
     flow->vlan_tci = tci;
+    flow->vlan_tpid = flow->dl_type;
     flow->dl_type = htons(0);
 
     /* Now parse the encapsulated attributes. */
@@ -1962,7 +2023,8 @@ odp_flow_key_to_flow(const struct nlattr *key, size_t key_len,
         return ODP_FIT_ERROR;
     }
 
-    if (flow->dl_type == htons(ETH_TYPE_VLAN)) {
+    if (flow->dl_type == htons(ETH_TYPE_VLAN) ||
+        flow->dl_type == htons(ETH_TYPE_VLAN_8021AD)) {
         return parse_8021q_onward(attrs, present_attrs, out_of_range_attr,
                                   expected_attrs, flow, key, key_len);
     }
@@ -2057,6 +2119,36 @@ commit_set_ether_addr_action(const struct flow *flow, struct flow *base,
 }
 
 static void
+commit_vlan_qinq_action(const struct flow *flow, struct flow *base,
+                   struct ofpbuf *odp_actions)
+{
+    if ((base->vlan_qinq_tci == flow->vlan_qinq_tci) &&
+        (base->vlan_tpid == flow->vlan_tpid)) {
+        return;
+    }
+
+    if (base->vlan_qinq_tci & htons(VLAN_CFI)) {
+        nl_msg_put_flag(odp_actions, OVS_ACTION_ATTR_POP_VLAN);
+    }
+
+    if (flow->vlan_qinq_tci & htons(VLAN_CFI)) {
+        struct ovs_action_push_vlan vlan;
+
+        /* For actions push_vlan:0x8100/0x88a8, followed by strip_vlan
+         * should be a no-op.
+         * For actions strip_vlan, followed by push_vlan:0x8100/0x88a8
+         * new vlan header is pushed.
+         */
+        vlan.vlan_tpid = htons(ETH_TYPE_VLAN);
+        vlan.vlan_tci = flow->vlan_qinq_tci;
+        nl_msg_put_unspec(odp_actions, OVS_ACTION_ATTR_PUSH_VLAN,
+                          &vlan, sizeof vlan);
+    }
+    base->vlan_tpid = flow->vlan_tpid;
+    base->vlan_qinq_tci = flow->vlan_qinq_tci;
+}
+
+static void
 commit_vlan_action(const struct flow *flow, struct flow *base,
                    struct ofpbuf *odp_actions)
 {
@@ -2071,7 +2163,16 @@ commit_vlan_action(const struct flow *flow, struct flow *base,
     if (flow->vlan_tci & htons(VLAN_CFI)) {
         struct ovs_action_push_vlan vlan;
 
-        vlan.vlan_tpid = htons(ETH_TYPE_VLAN);
+        /* For actions push_vlan:0x8100/0x88a8, followed by strip_vlan
+         * should be a no-op.
+         * For actions strip_vlan, followed by push_vlan:0x8100/0x88a8
+         * new vlan header is pushed.
+         */
+        if (flow->vlan_tpid == htons(ETH_TYPE_VLAN_8021AD)) {
+            vlan.vlan_tpid = flow->vlan_tpid;
+        } else {
+            vlan.vlan_tpid = htons(ETH_TYPE_VLAN);
+        }
         vlan.vlan_tci = flow->vlan_tci;
         nl_msg_put_unspec(odp_actions, OVS_ACTION_ATTR_PUSH_VLAN,
                           &vlan, sizeof vlan);
@@ -2262,6 +2363,7 @@ commit_odp_actions(const struct flow *flow, struct flow *base,
 {
     commit_set_tun_id_action(flow, base, odp_actions);
     commit_set_ether_addr_action(flow, base, odp_actions);
+    commit_vlan_qinq_action(flow, base, odp_actions);
     commit_vlan_action(flow, base, odp_actions);
     commit_set_nw_action(flow, base, odp_actions);
     commit_set_port_action(flow, base, odp_actions);
diff --git a/lib/odp-util.h b/lib/odp-util.h
index db85c28..82c60d2 100644
--- a/lib/odp-util.h
+++ b/lib/odp-util.h
@@ -84,13 +84,14 @@ int odp_actions_from_string(const char *, const struct simap *port_names,
  *  OVS_KEY_ATTR_ETHERNET     12    --     4     16
  *  OVS_KEY_ATTR_ETHERTYPE     2     2     4      8  (outer VLAN ethertype)
  *  OVS_KEY_ATTR_8021Q         4    --     4      8
+ *  OVS_KEY_ATTR_8021AD        4    --     4      8
  *  OVS_KEY_ATTR_ENCAP         0    --     4      4  (VLAN encapsulation)
  *  OVS_KEY_ATTR_ETHERTYPE     2     2     4      8  (inner VLAN ethertype)
  *  OVS_KEY_ATTR_IPV6         40    --     4     44
  *  OVS_KEY_ATTR_ICMPV6        2     2     4      8
  *  OVS_KEY_ATTR_ND           28    --     4     32
  *  -------------------------------------------------
- *  total                                       156
+ *  total                                       160
  *
  * We include some slack space in case the calculation isn't quite right or we
  * add another field and forget to adjust this value.
diff --git a/lib/ofp-parse.c b/lib/ofp-parse.c
index 7fcaf13..e26f58e 100644
--- a/lib/ofp-parse.c
+++ b/lib/ofp-parse.c
@@ -326,6 +326,7 @@ parse_named_action(enum ofputil_action_code code, const struct flow *flow,
     struct nx_action_mpls_ttl *namttl;
     struct nx_action_push_mpls *nampush;
     struct nx_action_pop_mpls *nampop;
+    struct nx_action_push_vlan *navpush;
 
     switch (code) {
     case OFPUTIL_OFPAT10_OUTPUT:
@@ -480,6 +481,11 @@ parse_named_action(enum ofputil_action_code code, const struct flow *flow,
     case OFPUTIL_NXAST_CONTROLLER:
         parse_controller(b, arg);
         break;
+
+    case OFPUTIL_NXAST_PUSH_VLAN:
+        navpush = ofputil_put_NXAST_PUSH_VLAN(b);
+        navpush->tpid = htons(str_to_u32(arg));
+        break;
     }
 }
 
diff --git a/lib/ofp-print.c b/lib/ofp-print.c
index 281e427..3abb3b2 100644
--- a/lib/ofp-print.c
+++ b/lib/ofp-print.c
@@ -184,6 +184,7 @@ ofp_print_action(struct ds *s, const union ofp_action *a,
     const struct nx_action_output_reg *naor;
     const struct nx_action_fin_timeout *naft;
     const struct nx_action_controller *nac;
+    const struct nx_action_push_vlan *navpush;
     struct mf_subfield subfield;
     uint16_t port;
 
@@ -415,6 +416,11 @@ ofp_print_action(struct ds *s, const union ofp_action *a,
         ds_put_char(s, ')');
         break;
 
+   case OFPUTIL_NXAST_PUSH_VLAN:
+        navpush = (const struct nx_action_push_vlan *) a;
+        ds_put_format(s, "push_vlan:0x%"PRIx16, ntohs(navpush->tpid));
+        break;
+
     default:
         break;
     }
diff --git a/lib/ofp-util.c b/lib/ofp-util.c
index f148f99..c78c4ce 100644
--- a/lib/ofp-util.c
+++ b/lib/ofp-util.c
@@ -103,7 +103,7 @@ static const flow_wildcards_t WC_INVARIANTS = 0
 void
 ofputil_wildcard_from_ofpfw10(uint32_t ofpfw, struct flow_wildcards *wc)
 {
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     /* Initialize most of rule->wc. */
     flow_wildcards_init_catchall(wc);
@@ -112,7 +112,8 @@ ofputil_wildcard_from_ofpfw10(uint32_t ofpfw, struct flow_wildcards *wc)
     /* Wildcard fields that aren't defined by ofp10_match or tun_id. */
     wc->wildcards |= (FWW_ARP_SHA | FWW_ARP_THA | FWW_NW_ECN | FWW_NW_TTL
                       | FWW_IPV6_LABEL | FWW_MPLS_LABEL | FWW_MPLS_TC
-                      | FWW_MPLS_STACK);
+                      | FWW_MPLS_STACK | FWW_VLAN_TPID | FWW_VLAN_QINQ_VID
+                      | FWW_VLAN_QINQ_PCP);
 
     if (ofpfw & OFPFW10_NW_TOS) {
         /* OpenFlow 1.0 defines a TOS wildcard, but it's much later in
@@ -1443,7 +1444,7 @@ ofputil_usable_protocols(const struct cls_rule *rule)
 {
     const struct flow_wildcards *wc = &rule->wc;
 
-    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 12);
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 13);
 
     /* NXM and OF1.1+ supports bitwise matching on ethernet addresses. */
     if (!eth_mask_is_exact(wc->dl_src_mask)
@@ -1522,6 +1523,21 @@ ofputil_usable_protocols(const struct cls_rule *rule)
         return OFPUTIL_P_NXM_ANY;
     }
 
+    /* Only NXM supports matching vlan tpid */
+    if (!(wc->wildcards & FWW_VLAN_TPID)) {
+        return OFPUTIL_P_NXM_ANY;
+    }
+
+    /* Only NXM supports matching vlan qinq vid */
+    if (!(wc->wildcards & FWW_VLAN_QINQ_VID)) {
+        return OFPUTIL_P_NXM_ANY;
+    }
+
+    /* Only NXM supports matching vlan qinq pcp */
+    if (!(wc->wildcards & FWW_VLAN_QINQ_PCP)) {
+        return OFPUTIL_P_NXM_ANY;
+    }
+
     /* Other formats can express this rule. */
     return OFPUTIL_P_ANY;
 }
@@ -3703,7 +3719,7 @@ validate_actions(const union ofp_action *actions, size_t n_actions,
         enum ofperr error;
         uint16_t port;
         int code;
-        ovs_be16 etype;
+        ovs_be16 etype, vtpid;
         ovs_be32 mpls_label;
         uint8_t mpls_tc, mpls_ttl;
 
@@ -3773,6 +3789,14 @@ validate_actions(const union ofp_action *actions, size_t n_actions,
             }
             break;
 
+        case OFPUTIL_NXAST_PUSH_VLAN:
+            vtpid = ((const struct nx_action_push_vlan *) a)->tpid;
+            if (vtpid != htons(ETH_TYPE_VLAN) &&
+                vtpid != htons(ETH_TYPE_VLAN_8021AD)) {
+                error = OFPERR_OFPBAC_BAD_ARGUMENT;
+            }
+            break;
+
         case OFPUTIL_OFPAT10_ENQUEUE:
             port = ntohs(((const struct ofp_action_enqueue *) a)->port);
             if (port >= max_ports && port != OFPP_IN_PORT
@@ -4102,6 +4126,7 @@ ofputil_normalize_rule(struct cls_rule *rule)
         MAY_IPV6        = 1 << 6, /* ipv6_src, ipv6_dst, ipv6_label */
         MAY_ND_TARGET   = 1 << 7, /* nd_target */
         MAY_MPLS        = 1 << 8, /* mpls label and tc */
+        MAY_VLAN_QINQ   = 1 << 9, /* vlan qinq tci */
     } may_match;
 
     struct flow_wildcards wc;
@@ -4132,6 +4157,10 @@ ofputil_normalize_rule(struct cls_rule *rule)
     } else if (rule->flow.dl_type == htons(ETH_TYPE_MPLS) ||
                rule->flow.dl_type == htons(ETH_TYPE_MPLS_MCAST)) {
         may_match = MAY_MPLS;
+    } else if ((rule->flow.vlan_tpid == htons(ETH_TYPE_VLAN) ||
+                rule->flow.vlan_tpid == htons(ETH_TYPE_VLAN_8021AD)) &&
+               rule->flow.vlan_qinq_tci != htons(0)) {
+        may_match = MAY_VLAN_QINQ;
     } else {
         may_match = 0;
     }
diff --git a/lib/ofp-util.def b/lib/ofp-util.def
index 0380a84..c53b73c 100644
--- a/lib/ofp-util.def
+++ b/lib/ofp-util.def
@@ -47,4 +47,5 @@ NXAST_ACTION(NXAST_SET_MPLS_TTL,   nx_action_mpls_ttl,     0, "set_mpls_ttl")
 NXAST_ACTION(NXAST_DEC_MPLS_TTL,   nx_action_header,       0, "dec_mpls_ttl")
 NXAST_ACTION(NXAST_PUSH_MPLS,      nx_action_push_mpls,    0, "push_mpls")
 NXAST_ACTION(NXAST_POP_MPLS,       nx_action_pop_mpls,     0, "pop_mpls")
+NXAST_ACTION(NXAST_PUSH_VLAN,      nx_action_push_vlan,    0, "push_vlan")
 #undef NXAST_ACTION
diff --git a/lib/packets.c b/lib/packets.c
index 3ccad03..db02f7e 100644
--- a/lib/packets.c
+++ b/lib/packets.c
@@ -159,16 +159,16 @@ compose_rarp(struct ofpbuf *b, const uint8_t eth_src[ETH_ADDR_LEN])
  *
  * Also sets 'packet->l2' to point to the new Ethernet header. */
 void
-eth_push_vlan(struct ofpbuf *packet, ovs_be16 tci)
+eth_push_vlan(struct ofpbuf *packet, ovs_be16 tci, ovs_be16 tpid)
 {
     struct eth_header *eh = packet->data;
     struct vlan_eth_header *veh;
 
-    /* Insert new 802.1Q header. */
+    /* Insert new 802.1Q or 802.1AD header. */
     struct vlan_eth_header tmp;
     memcpy(tmp.veth_dst, eh->eth_dst, ETH_ADDR_LEN);
     memcpy(tmp.veth_src, eh->eth_src, ETH_ADDR_LEN);
-    tmp.veth_type = htons(ETH_TYPE_VLAN);
+    tmp.veth_type = tpid;
     tmp.veth_tci = tci & htons(~VLAN_CFI);
     tmp.veth_next_type = eh->eth_type;
 
@@ -186,7 +186,8 @@ eth_pop_vlan(struct ofpbuf *packet)
 {
     struct vlan_eth_header *veh = packet->l2;
     if (packet->size >= sizeof *veh
-        && veh->veth_type == htons(ETH_TYPE_VLAN)) {
+        && (veh->veth_type == htons(ETH_TYPE_VLAN) ||
+            veh->veth_type == htons(ETH_TYPE_VLAN_8021AD))) {
         struct eth_header tmp;
 
         memcpy(tmp.eth_dst, veh->veth_dst, ETH_ADDR_LEN);
@@ -205,7 +206,8 @@ set_ethertype(struct ofpbuf *packet, ovs_be16 eth_type)
 {
     struct eth_header *eh = packet->data;
 
-    if (eh->eth_type == htons(ETH_TYPE_VLAN)) {
+    if (eh->eth_type == htons(ETH_TYPE_VLAN) ||
+        eh->eth_type == htons(ETH_TYPE_VLAN_8021AD)) {
         /* ethtype for VLAN packets is at L3_offset - 2 bytes. */
         ovs_be16 *next_ethtype;
         next_ethtype = (ovs_be16 *)((char *)packet->l3 - 2);
@@ -223,7 +225,8 @@ get_ethertype(struct ofpbuf *packet)
     char *mh = packet->l2_5;
     ovs_be16 *ethtype = NULL;
 
-    if (eh->eth_type == htons(ETH_TYPE_VLAN)) {
+    if (eh->eth_type == htons(ETH_TYPE_VLAN) ||
+        eh->eth_type == htons(ETH_TYPE_VLAN_8021AD)) {
         if (mh != NULL) {
             ethtype = (ovs_be16 *)(mh - 2);
         } else {
diff --git a/lib/packets.h b/lib/packets.h
index f536437..c767422 100644
--- a/lib/packets.h
+++ b/lib/packets.h
@@ -137,7 +137,7 @@ bool eth_addr_from_string(const char *, uint8_t ea[ETH_ADDR_LEN]);
 
 void compose_rarp(struct ofpbuf *, const uint8_t eth_src[ETH_ADDR_LEN]);
 
-void eth_push_vlan(struct ofpbuf *, ovs_be16 tci);
+void eth_push_vlan(struct ofpbuf *, ovs_be16 tci, ovs_be16 tpid);
 void eth_pop_vlan(struct ofpbuf *);
 
 const char *eth_from_hex(const char *hex, struct ofpbuf **packetp);
@@ -186,12 +186,14 @@ void pop_mpls(struct ofpbuf *, ovs_be16 ethtype);
 
 #define ETH_TYPE_IP            0x0800
 #define ETH_TYPE_ARP           0x0806
-#define ETH_TYPE_VLAN          0x8100
 #define ETH_TYPE_IPV6          0x86dd
 #define ETH_TYPE_LACP          0x8809
 #define ETH_TYPE_RARP          0x8035
 #define ETH_TYPE_MPLS          0x8847
 #define ETH_TYPE_MPLS_MCAST    0x8848
+#define ETH_TYPE_VLAN_8021Q    0x8100
+#define ETH_TYPE_VLAN_8021AD   0x88a8
+#define ETH_TYPE_VLAN          ETH_TYPE_VLAN_8021Q
 
 /* Minimum value for an Ethernet type.  Values below this are IEEE 802.2 frame
  * lengths. */
@@ -292,7 +294,8 @@ BUILD_ASSERT_DECL(VLAN_HEADER_LEN == sizeof(struct vlan_header));
 struct vlan_eth_header {
     uint8_t veth_dst[ETH_ADDR_LEN];
     uint8_t veth_src[ETH_ADDR_LEN];
-    ovs_be16 veth_type;         /* Always htons(ETH_TYPE_VLAN). */
+    ovs_be16 veth_type;         /* Always htons(ETH_TYPE_VLAN) or
+                                          hotns(ETH_TYPE_VLAN_8021ad). */
     ovs_be16 veth_tci;          /* Lowest 12 bits are VLAN ID. */
     ovs_be16 veth_next_type;
 } __attribute__((packed));
diff --git a/ofproto/ofproto-dpif.c b/ofproto/ofproto-dpif.c
index 592d0b4..34294d5 100644
--- a/ofproto/ofproto-dpif.c
+++ b/ofproto/ofproto-dpif.c
@@ -2993,7 +2993,7 @@ ofproto_dpif_extract_flow_key(const struct ofproto_dpif *ofproto,
              * that 'packet' is inside a Netlink attribute: pushing 4 bytes
              * will just overwrite the 4-byte "struct nlattr", which is fine
              * since we don't need that header anymore. */
-            eth_push_vlan(packet, flow->vlan_tci);
+            eth_push_vlan(packet, flow->vlan_tci, htons(ETH_TYPE_VLAN));
         }
 
         /* Let the caller know that we can't reproduce 'key' from 'flow'. */
@@ -4861,6 +4861,7 @@ compose_output_action__(struct action_xlate_ctx *ctx, uint16_t ofp_port,
     const struct ofport_dpif *ofport = get_ofp_port(ctx->ofproto, ofp_port);
     uint16_t odp_port = ofp_port_to_odp_port(ofp_port);
     ovs_be16 flow_vlan_tci = ctx->flow.vlan_tci;
+    ovs_be16 flow_vlan_qinq_tci = ctx->flow.vlan_qinq_tci;
     ovs_be32 flow_mpls_lse = ctx->flow.mpls_lse;
     uint8_t flow_nw_tos = ctx->flow.nw_tos;
     uint16_t out_port;
@@ -4896,6 +4897,7 @@ compose_output_action__(struct action_xlate_ctx *ctx, uint16_t ofp_port,
     ctx->sflow_n_outputs++;
     ctx->nf_output_iface = ofp_port;
     ctx->flow.vlan_tci = flow_vlan_tci;
+    ctx->flow.vlan_qinq_tci = flow_vlan_qinq_tci;
     ctx->flow.mpls_lse = flow_mpls_lse;
     ctx->flow.nw_tos = flow_nw_tos;
 }
@@ -5024,6 +5026,11 @@ execute_controller_action(struct action_xlate_ctx *ctx, int len,
         struct eth_header *eh;
 
         eth_pop_vlan(packet);
+        /* Handle VLAN QinQ packets. */
+        if (ctx->flow.vlan_qinq_tci != htons(0)) {
+            eth_pop_vlan(packet);
+        }
+
         eh = packet->l2;
 
         /* If the Ethernet type is less than ETH_TYPE_MIN, it's likely an 802.2
@@ -5036,7 +5043,11 @@ execute_controller_action(struct action_xlate_ctx *ctx, int len,
         memcpy(eh->eth_dst, ctx->flow.dl_dst, sizeof eh->eth_dst);
 
         if (ctx->flow.vlan_tci & htons(VLAN_CFI)) {
-            eth_push_vlan(packet, ctx->flow.vlan_tci);
+            eth_push_vlan(packet, ctx->flow.vlan_tci, ctx->flow.vlan_tpid);
+        }
+
+        if (ctx->flow.vlan_qinq_tci & htons(VLAN_CFI)) {
+            eth_push_vlan(packet, ctx->flow.vlan_qinq_tci, htons(ETH_TYPE_VLAN));
         }
 
         if (ctx->flow.mpls_lse) {
@@ -5399,6 +5410,7 @@ do_xlate_actions(const union ofp_action *in, size_t n_in,
         const struct nx_action_bundle *nab;
         const struct nx_action_output_reg *naor;
         const struct nx_action_controller *nac;
+        const struct nx_action_push_vlan *navpush;
         enum ofputil_action_code code;
         ovs_be64 tun_id;
         ovs_be32 mpls_label;
@@ -5416,16 +5428,27 @@ do_xlate_actions(const union ofp_action *in, size_t n_in,
         case OFPUTIL_OFPAT10_SET_VLAN_VID:
             ctx->flow.vlan_tci &= ~htons(VLAN_VID_MASK);
             ctx->flow.vlan_tci |= ia->vlan_vid.vlan_vid | htons(VLAN_CFI);
+            if (ctx->flow.vlan_tpid == htons(0)) {
+                ctx->flow.vlan_tpid = htons(ETH_TYPE_VLAN);
+            }
             break;
 
         case OFPUTIL_OFPAT10_SET_VLAN_PCP:
             ctx->flow.vlan_tci &= ~htons(VLAN_PCP_MASK);
             ctx->flow.vlan_tci |= htons(
                 (ia->vlan_pcp.vlan_pcp << VLAN_PCP_SHIFT) | VLAN_CFI);
+            if (ctx->flow.vlan_tpid == htons(0)) {
+                ctx->flow.vlan_tpid = htons(ETH_TYPE_VLAN);
+            }
             break;
 
         case OFPUTIL_OFPAT10_STRIP_VLAN:
-            ctx->flow.vlan_tci = htons(0);
+            if (ctx->flow.vlan_tci != 0) {
+                ctx->flow.vlan_tci = htons(0);
+                ctx->flow.vlan_tpid = htons(0);
+            } else if (ctx->flow.vlan_qinq_tci != 0) {
+                ctx->flow.vlan_qinq_tci = htons(0);
+            }
             break;
 
         case OFPUTIL_OFPAT10_SET_DL_SRC:
@@ -5615,6 +5638,25 @@ do_xlate_actions(const union ofp_action *in, size_t n_in,
             execute_controller_action(ctx, ntohs(nac->max_len), nac->reason,
                                       ntohs(nac->controller_id));
             break;
+
+        case OFPUTIL_NXAST_PUSH_VLAN:
+            if (ctx->base_flow.vlan_tci != 0) {
+                navpush = (const struct nx_action_push_vlan *) ia;
+                /* For actions configured as
+                 * strip_vlan,push_vlan:0x8100/0x88a8 - Push a new vlan header.
+                 * push_vlan:0x8100/0x88a8,strip_vlan - no-op. */
+                ctx->flow.vlan_tpid = navpush->tpid;
+                if (ctx->flow.vlan_tci != htons(0)) {
+                    ctx->flow.vlan_qinq_tci = ctx->base_flow.vlan_tci;
+                } else {
+                    ctx->flow.vlan_tci = ctx->base_flow.vlan_tci;
+                }
+            } else if (ctx->flow.vlan_tci != htons(0)) {
+                navpush = (const struct nx_action_push_vlan *) ia;
+                ctx->flow.vlan_tpid = navpush->tpid;
+                ctx->flow.vlan_qinq_tci = ctx->flow.vlan_tci;
+            }
+            break;
         }
     }
 
@@ -6233,7 +6275,8 @@ xlate_normal(struct action_xlate_ctx *ctx)
     }
 
     /* Drop malformed frames. */
-    if (ctx->flow.dl_type == htons(ETH_TYPE_VLAN) &&
+    if ((ctx->flow.dl_type == htons(ETH_TYPE_VLAN) ||
+         ctx->flow.dl_type == htons(ETH_TYPE_VLAN_8021AD)) &&
         !(ctx->flow.vlan_tci & htons(VLAN_CFI))) {
         if (ctx->packet != NULL) {
             static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);
diff --git a/tests/odp.at b/tests/odp.at
index f22bd69..dc7b8a0 100644
--- a/tests/odp.at
+++ b/tests/odp.at
@@ -52,6 +52,14 @@ s/$/)/' odp-base.txt
  sed 's/\(eth([[^)]]*)\),*/\1,eth_type(0x8848),mpls(label=100,tc=7,ttl=64,bos=1)' odp-base.txt
 
  echo
+ echo '# Valid forms with VLAN QinQ (8021Q) header.'
+ sed 's/\(eth([[^)]]*)\),*/\1,eth_type(0x8100),vlan(vid=99,pcp=7),vlan_qinq(vid=99,pcp=7),encap(/s/$/)/' odp-base.txt
+
+ echo
+ echo '# Valid forms with VLAN QinQ (8021AD) header.'
+ sed 's/\(eth([[^)]]*)\),*/\1,eth_type(0x88a8),vlan(vid=99,pcp=7),vlan_qinq(vid=99,pcp=7),encap(/s/$/)/' odp-base.txt
+
+ echo
  echo '# Valid forms with QoS priority.'
  sed 's/^/priority(1234),/' odp-base.txt
 
@@ -62,12 +70,32 @@ s/\(eth([[^)]]*)\),*/\1,eth_type(0x8100),vlan(vid=99,pcp=7),encap(/
 s/$/)/' odp-base.txt
 
  echo
+ echo '# Valid forms with tun_id and VLAN QinQ (8021Q) headers.'
+ sed 's/^/tun_id(0xfedcba9876543210),/
+s/\(eth([[^)]]*)\),*/\1,eth_type(0x8100),vlan(vid=99,pcp=7),vlan_qinq(vid=99,pcp=7),encap(/s/$/)/' odp-base.txt
+
+ echo
+ echo '# Valid forms with tun_id and VLAN QinQ (8021AD) headers.'
+ sed 's/^/tun_id(0xfedcba9876543210),/
+s/\(eth([[^)]]*)\),*/\1,eth_type(0x88a8),vlan(vid=99,pcp=7),vlan_qinq(vid=99,pcp=7),encap(/s/$/)/' odp-base.txt
+
+ echo
  echo '# Valid forms with QOS priority, tun_id, and VLAN headers.'
  sed 's/^/priority(1234),tun_id(0xfedcba9876543210),/
 s/\(eth([[^)]]*)\),*/\1,eth_type(0x8100),vlan(vid=99,pcp=7),encap(/
 s/$/)/' odp-base.txt
 
  echo
+ echo '# Valid forms with QOS priority, tun_id, and VLAN QinQ (8021Q) headers.'
+ sed 's/^/priority(1234),tun_id(0xfedcba9876543210),/
+s/\(eth([[^)]]*)\),*/\1,eth_type(0x8100),vlan(vid=99,pcp=7),vlan_qinq(vid=99,pcp=7),encap(/s/$/)/' odp-base.txt
+
+ echo
+ echo '# Valid forms with QOS priority, tun_id, and VLAN QinQ (8021AD) headers.'
+ sed 's/^/priority(1234),tun_id(0xfedcba9876543210),/
+s/\(eth([[^)]]*)\),*/\1,eth_type(0x88a8),vlan(vid=99,pcp=7),vlan_qinq(vid=99,pcp=7),encap(/s/$/)/' odp-base.txt
+
+ echo
  echo '# Valid forms with IP first fragment.'
 sed -n 's/,frag=no),/,frag=first),/p' odp-base.txt
 
@@ -98,10 +126,12 @@ set(udp(src=81,dst=6632))
 set(icmp(type=1,code=2))
 set(ipv6(src=::1,dst=::2,label=0,proto=10,tclass=0x70,hlimit=128,frag=no))
 set(icmpv6(type=1,code=2))
-push_vlan(vid=12,pcp=0)
-push_vlan(vid=13,pcp=5,cfi=0)
+push_vlan(tpid=0x8100,vid=12,pcp=0)
+push_vlan(tpid=0x8100,vid=13,pcp=5,cfi=0)
 push_vlan(tpid=0x9100,vid=13,pcp=5)
 push_vlan(tpid=0x9100,vid=13,pcp=5,cfi=0)
+push_vlan(tpid=0x88a8,vid=13,pcp=5)
+push_vlan(tpid=0x88a8,vid=13,pcp=5,cfi=0)
 push_mpls(eth_type=0x8847)
 push_mpls(eth_type=0x8848)
 mpls_lse(label=100,tc=3,ttl=64,bos=0)
@@ -110,7 +140,7 @@ dec_mpls_ttl
 copy_ttl_in
 copy_ttl_out
 pop_vlan
-sample(sample=9.7%,actions(1,2,3,push_vlan(vid=1,pcp=2)))
+sample(sample=9.7%,actions(1,2,3,push_vlan(tpid=0x8100,vid=1,pcp=2)))
 ])
 AT_CHECK_UNQUOTED([test-odp parse-actions < actions.txt], [0],
   [`cat actions.txt`
diff --git a/tests/ofp-print.at b/tests/ofp-print.at
index 071ebd1..4c55d6a 100644
--- a/tests/ofp-print.at
+++ b/tests/ofp-print.at
@@ -278,7 +278,7 @@ c0 a8 00 02 27 2f 00 00 78 50 cc 5b 57 af 42 1e \
 50 00 02 00 26 e8 00 00 00 00 00 00 00 00 \
 "], [0], [dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=3 (via no_match) data_len=60 buffer=0x00000111
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:06) type:0800,mpls(0) proto:6 tos:0 ttl:64 ip(192.168.0.1->192.168.0.2) port(10031->0) tcp_csum:26e8
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:06) type:0800,mpls(0) proto:6 tos:0 ttl:64 ip(192.168.0.1->192.168.0.2) port(10031->0) tcp_csum:26e8
 ])
 AT_CLEANUP
 
@@ -775,7 +775,7 @@ ff ff ff ff 00 40 01 07 00 00 00 00 00 00 00 09 \
 31 6d 00 00 00 00 00 00 00 00 \
 "], [0], [dnl
 NXT_PACKET_IN (xid=0x0): table_id=7 cookie=0x9 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) tcp_csum:316d
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) tcp_csum:316d
 ])
 AT_CLEANUP
 
diff --git a/tests/ofproto-dpif.at b/tests/ofproto-dpif.at
index 7936cf9..ee46d74 100644
--- a/tests/ofproto-dpif.at
+++ b/tests/ofproto-dpif.at
@@ -97,7 +97,7 @@ AT_CHECK([ovs-appctl ofproto/trace br0 'in_port(1),eth(src=50:54:00:00:00:05,dst
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): table_id=1 total_len=42 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via invalid_ttl) data_len=42 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:1 tos:0 ttl:1 ip(192.168.0.1->192.168.0.2)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:1 tos:0 ttl:1 ip(192.168.0.1->192.168.0.2)
 ])
 OVS_VSWITCHD_STOP
 AT_CLEANUP
@@ -253,6 +253,8 @@ cookie=0xa dl_src=40:44:44:44:44:44 actions=push_mpls:0x8847,set_mpls_label:10,s
 cookie=0xb dl_src=50:55:55:55:55:55 actions=set_mpls_label:1000,set_mpls_ttl:200,copy_ttl_out,controller
 cookie=0xd dl_src=60:66:66:66:66:66 actions=pop_mpls:0x0800,controller
 cookie=0xc dl_src=70:77:77:77:77:77 actions=push_mpls:0x8848,set_mpls_label:1000,set_mpls_tc:7,set_mpls_ttl:250,controller
+cookie=0xe dl_src=90:99:99:99:99:99 actions=mod_vlan_vid:101,mod_vlan_pcp:5,push_vlan:0x88a8,mod_vlan_vid:201,controller
+cookie=0xd dl_src=80:88:88:88:88:88 actions=mod_vlan_vid:100,mod_vlan_pcp:3,push_vlan:0x8100,mod_vlan_vid:200,mod_vlan_pcp:4,controller
 ])
 AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
 
@@ -266,13 +268,13 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=1 (via no_match) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->9) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->9) tcp_csum:0
 dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=1 (via no_match) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->9) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->9) tcp_csum:0
 dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=1 (via no_match) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->9) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:54:00:00:00:05->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->9) tcp_csum:0
 ])
 
 dnl Singleton controller action.
@@ -285,13 +287,13 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=1 (via action) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(10:11:11:11:11:11->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(10:11:11:11:11:11->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
 dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=1 (via action) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(10:11:11:11:11:11->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(10:11:11:11:11:11->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
 dnl
 OFPT_PACKET_IN (xid=0x0): total_len=60 in_port=1 (via action) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(10:11:11:11:11:11->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(10:11:11:11:11:11->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
 ])
 
 dnl Modified controller action.
@@ -304,13 +306,51 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 OFPT_PACKET_IN (xid=0x0): total_len=64 in_port=1 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:15,pcp:0) mac(30:33:33:33:33:33->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(vlan:15,pcp:0),qinq_tci(0) mac(30:33:33:33:33:33->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
 dnl
 OFPT_PACKET_IN (xid=0x0): total_len=64 in_port=1 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:15,pcp:0) mac(30:33:33:33:33:33->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(vlan:15,pcp:0),qinq_tci(0) mac(30:33:33:33:33:33->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
 dnl
 OFPT_PACKET_IN (xid=0x0): total_len=64 in_port=1 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:15,pcp:0) mac(30:33:33:33:33:33->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(vlan:15,pcp:0),qinq_tci(0) mac(30:33:33:33:33:33->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+])
+
+dnl Modified vlan qinq controller action.
+AT_CHECK([ovs-ofctl monitor br0 65534 -P nxm --detach --pidfile 2> ofctl_monitor.log])
+
+for i in 1 2 3; do
+    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=90:99:99:99:99:99,dst=50:54:00:00:00:07),eth_type(0x0800) ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)'
+done
+
+OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
+AT_CHECK([cat ofctl_monitor.log], [0], [dnl
+NXT_PACKET_IN (xid=0x0): cookie=0xe total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
+priority:0,tunnel:0,in_port:0000,tci(vlan:101,pcp:5),qinq_tci(vlan:201,pcp:5) mac(90:99:99:99:99:99->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) tcp_csum:0
+dnl
+NXT_PACKET_IN (xid=0x0): cookie=0xe total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
+priority:0,tunnel:0,in_port:0000,tci(vlan:101,pcp:5),qinq_tci(vlan:201,pcp:5) mac(90:99:99:99:99:99->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) tcp_csum:0
+dnl
+NXT_PACKET_IN (xid=0x0): cookie=0xe total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
+priority:0,tunnel:0,in_port:0000,tci(vlan:101,pcp:5),qinq_tci(vlan:201,pcp:5) mac(90:99:99:99:99:99->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) tcp_csum:0
+])
+
+dnl Modified vlan qinq controller action.
+AT_CHECK([ovs-ofctl monitor br0 65534 -P nxm --detach --pidfile 2> ofctl_monitor.log])
+
+for i in 1 2 3; do
+    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=80:88:88:88:88:88,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no),tcp(src=8,dst=10)'
+done
+
+OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
+AT_CHECK([cat ofctl_monitor.log], [0], [dnl
+NXT_PACKET_IN (xid=0x0): cookie=0xd total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
+priority:0,tunnel:0,in_port:0000,tci(vlan:100,pcp:3),qinq_tci(vlan:200,pcp:4) mac(80:88:88:88:88:88->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+dnl
+NXT_PACKET_IN (xid=0x0): cookie=0xd total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
+priority:0,tunnel:0,in_port:0000,tci(vlan:100,pcp:3),qinq_tci(vlan:200,pcp:4) mac(80:88:88:88:88:88->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
+dnl
+NXT_PACKET_IN (xid=0x0): cookie=0xd total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
+priority:0,tunnel:0,in_port:0000,tci(vlan:100,pcp:3),qinq_tci(vlan:200,pcp:4) mac(80:88:88:88:88:88->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->10) tcp_csum:0
 ])
 
 dnl Modified mpls controller action.
@@ -323,13 +363,13 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xa total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=48 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(40:44:44:44:44:44->50:54:00:00:00:07) type:8847,mpls(label:10,tc:3,ttl:64,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(40:44:44:44:44:44->50:54:00:00:00:07) type:8847,mpls(label:10,tc:3,ttl:64,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xa total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=48 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(40:44:44:44:44:44->50:54:00:00:00:07) type:8847,mpls(label:10,tc:3,ttl:64,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(40:44:44:44:44:44->50:54:00:00:00:07) type:8847,mpls(label:10,tc:3,ttl:64,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xa total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(40:44:44:44:44:44->50:54:00:00:00:07) type:8847,mpls(label:10,tc:3,ttl:64,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(40:44:44:44:44:44->50:54:00:00:00:07) type:8847,mpls(label:10,tc:3,ttl:64,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 ])
 
 dnl Modified mpls ttl action.
@@ -342,13 +382,13 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xb total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:55:55:55:55:55->50:54:00:00:00:07) type:8847,mpls(label:1000,tc:7,ttl:200,bos:1),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:55:55:55:55:55->50:54:00:00:00:07) type:8847,mpls(label:1000,tc:7,ttl:200,bos:1),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xb total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:55:55:55:55:55->50:54:00:00:00:07) type:8847,mpls(label:1000,tc:7,ttl:200,bos:1),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:55:55:55:55:55->50:54:00:00:00:07) type:8847,mpls(label:1000,tc:7,ttl:200,bos:1),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xb total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(50:55:55:55:55:55->50:54:00:00:00:07) type:8847,mpls(label:1000,tc:7,ttl:200,bos:1),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(50:55:55:55:55:55->50:54:00:00:00:07) type:8847,mpls(label:1000,tc:7,ttl:200,bos:1),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no)
 ])
 
 dnl Modified mpls ipv6 controller action.
@@ -361,13 +401,13 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xc total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(70:77:77:77:77:77->50:54:00:00:00:07) type:8848,mpls(label:1000,tc:7,ttl:250,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(70:77:77:77:77:77->50:54:00:00:00:07) type:8848,mpls(label:1000,tc:7,ttl:250,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xc total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(70:77:77:77:77:77->50:54:00:00:00:07) type:8848,mpls(label:1000,tc:7,ttl:250,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(70:77:77:77:77:77->50:54:00:00:00:07) type:8848,mpls(label:1000,tc:7,ttl:250,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xc total_len=68 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(70:77:77:77:77:77->50:54:00:00:00:07) type:8848,mpls(label:1000,tc:7,ttl:250,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(70:77:77:77:77:77->50:54:00:00:00:07) type:8848,mpls(label:1000,tc:7,ttl:250,bos:1) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 ])
 
 dnl Modified mpls pop action.
@@ -380,13 +420,13 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xd total_len=60 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0), mac(60:66:66:66:66:66->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(60:66:66:66:66:66->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xd total_len=60 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0), mac(60:66:66:66:66:66->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(60:66:66:66:66:66->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2)
 dnl
 NXT_PACKET_IN (xid=0x0): cookie=0xd total_len=60 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=68 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0), mac(60:66:66:66:66:66->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(60:66:66:66:66:66->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2)
 ])
 
 dnl Checksum TCP.
@@ -399,31 +439,31 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): cookie=0x1 total_len=60 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=1 cookie=0x3 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=2 cookie=0x4 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x2 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->50:54:00:00:00:07) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=3 cookie=0x5 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) tcp_csum:0
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=4 cookie=0x6 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->192.168.0.2) port(8->11) tcp_csum:1a03
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->192.168.0.2) port(8->11) tcp_csum:1a03
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=5 cookie=0x7 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(8->11) tcp_csum:3205
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(8->11) tcp_csum:3205
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=6 cookie=0x8 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->11) tcp_csum:31b8
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->11) tcp_csum:31b8
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=7 cookie=0x9 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) tcp_csum:316d
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) tcp_csum:316d
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=7 cookie=0x9 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) tcp_csum:316d
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:6 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) tcp_csum:316d
 ])
 
 dnl Checksum UDP.
@@ -436,31 +476,31 @@ done
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN (xid=0x0): cookie=0x1 total_len=60 in_port=1 tun_id=0x0 reg0=0x0 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=60 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=1 cookie=0x3 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x0 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(20:22:22:22:22:22->50:54:00:00:00:07) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=2 cookie=0x4 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x2 reg2=0x0 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->50:54:00:00:00:07) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->50:54:00:00:00:07) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=3 cookie=0x5 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x0 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(192.168.0.1->192.168.0.2) port(8->11) udp_csum:1234
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=4 cookie=0x6 total_len=64 in_port=1 tun_id=0x0 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x0 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->192.168.0.2) port(8->11) udp_csum:2c37
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->192.168.0.2) port(8->11) udp_csum:2c37
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=5 cookie=0x7 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(8->11) udp_csum:4439
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(8->11) udp_csum:4439
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=6 cookie=0x8 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->11) udp_csum:43ec
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->11) udp_csum:43ec
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=7 cookie=0x9 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) udp_csum:43a1
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) udp_csum:43a1
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=7 cookie=0x9 total_len=64 in_port=1 tun_id=0x6 reg0=0x1 reg1=0x2 reg2=0x3 reg3=0x4 reg4=0x5 reg5=0x0 reg6=0x0 reg7=0x0 (via action) data_len=64 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) udp_csum:43a1
+priority:0,tunnel:0,in_port:0000,tci(vlan:80,pcp:0),qinq_tci(0) mac(80:81:81:81:81:81->82:82:82:82:82:82) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(83.83.83.83->84.84.84.84) port(85->86) udp_csum:43a1
 ])
 
 AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
@@ -477,6 +517,8 @@ AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
  cookie=0xb, n_packets=3, n_bytes=180, dl_src=50:55:55:55:55:55 actions=set_mpls_label:1000,set_mpls_ttl:200,copy_ttl_out,CONTROLLER:65535
  cookie=0xd, n_packets=3, n_bytes=180, dl_src=60:66:66:66:66:66 actions=pop_mpls:0x0800,CONTROLLER:65535
  cookie=0xc, n_packets=3, n_bytes=180, dl_src=70:77:77:77:77:77 actions=push_mpls:0x8848,set_mpls_label:1000,set_mpls_tc:7,set_mpls_ttl:250,dec_mpls_ttl,CONTROLLER:65535
+ cookie=0xd, n_packets=3, n_bytes=180, dl_src=80:88:88:88:88:88 actions=mod_vlan_vid:100,mod_vlan_pcp:3,push_vlan:0x8100,mod_vlan_vid:200,mod_vlan_pcp:4,CONTROLLER:65535
+ cookie=0xe, n_packets=3, n_bytes=180, dl_src=90:99:99:99:99:99 actions=mod_vlan_vid:101,mod_vlan_pcp:5,push_vlan:0x88a8,mod_vlan_vid:201,CONTROLLER:65535
  n_packets=3, n_bytes=180, dl_src=10:11:11:11:11:11 actions=CONTROLLER:65535
 NXST_FLOW reply:
 ])
@@ -518,7 +560,7 @@ for tuple in \
         "0 11   0 5,7" \
         "0 11   1 5,7" \
         "0 12   0 1,5,6,pop_vlan,3,4,7,8" \
-        "0 12   1 1,5,6,pop_vlan,4,7,push_vlan(vid=0,pcp=1),3,8" \
+        "0 12   1 1,5,6,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=0,pcp=1),3,8" \
         "1  none 0 drop" \
         "1  0    0 drop" \
         "1  0    1 drop" \
@@ -527,70 +569,70 @@ for tuple in \
         "1  11   0 drop" \
         "1  11   1 drop" \
         "1  12   0 0,5,6,pop_vlan,3,4,7,8" \
-        "1  12   1 0,5,6,pop_vlan,4,7,push_vlan(vid=0,pcp=1),3,8" \
-        "2  none 0 push_vlan(vid=10,pcp=0),0,1,5,6,7,8" \
-        "2  0    0 pop_vlan,push_vlan(vid=10,pcp=0),0,1,5,6,7,8" \
-        "2  0    1 pop_vlan,push_vlan(vid=10,pcp=1),0,1,5,6,7,8" \
+        "1  12   1 0,5,6,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=0,pcp=1),3,8" \
+        "2  none 0 push_vlan(tpid=0x8100,vid=10,pcp=0),0,1,5,6,7,8" \
+        "2  0    0 pop_vlan,push_vlan(tpid=0x8100,vid=10,pcp=0),0,1,5,6,7,8" \
+        "2  0    1 pop_vlan,push_vlan(tpid=0x8100,vid=10,pcp=1),0,1,5,6,7,8" \
         "2  10   0 drop" \
         "2  10   1 drop" \
         "2  11   0 drop" \
         "2  11   1 drop" \
         "2  12   0 drop" \
         "2  12   1 drop" \
-        "3  none 0 4,7,8,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "3  0    0 pop_vlan,4,7,8,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "3  0    1 8,pop_vlan,4,7,push_vlan(vid=12,pcp=1),0,1,5,6" \
+        "3  none 0 4,7,8,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "3  0    0 pop_vlan,4,7,8,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "3  0    1 8,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=12,pcp=1),0,1,5,6" \
         "3  10   0 drop" \
         "3  10   1 drop" \
         "3  11   0 drop" \
         "3  11   1 drop" \
         "3  12   0 drop" \
         "3  12   1 drop" \
-        "4  none 0 3,7,8,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "4  0    0 pop_vlan,3,7,8,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "4  0    1 3,8,pop_vlan,7,push_vlan(vid=12,pcp=1),0,1,5,6" \
+        "4  none 0 3,7,8,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "4  0    0 pop_vlan,3,7,8,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "4  0    1 3,8,pop_vlan,7,push_vlan(tpid=0x8100,vid=12,pcp=1),0,1,5,6" \
         "4  10   0 drop" \
         "4  10   1 drop" \
         "4  11   0 drop" \
         "4  11   1 drop" \
         "4  12   0 drop" \
         "4  12   1 drop" \
-        "5  none 0 2,push_vlan(vid=10,pcp=0),0,1,6,7,8" \
-        "5  0    0 pop_vlan,2,push_vlan(vid=10,pcp=0),0,1,6,7,8" \
-        "5  0    1 pop_vlan,2,push_vlan(vid=10,pcp=1),0,1,6,7,8" \
+        "5  none 0 2,push_vlan(tpid=0x8100,vid=10,pcp=0),0,1,6,7,8" \
+        "5  0    0 pop_vlan,2,push_vlan(tpid=0x8100,vid=10,pcp=0),0,1,6,7,8" \
+        "5  0    1 pop_vlan,2,push_vlan(tpid=0x8100,vid=10,pcp=1),0,1,6,7,8" \
         "5  10   0 0,1,6,7,8,pop_vlan,2" \
         "5  10   1 0,1,6,7,8,pop_vlan,2" \
         "5  11   0 0,7" \
         "5  11   1 0,7" \
         "5  12   0 0,1,6,pop_vlan,3,4,7,8" \
-        "5  12   1 0,1,6,pop_vlan,4,7,push_vlan(vid=0,pcp=1),3,8" \
-        "6  none 0 2,push_vlan(vid=10,pcp=0),0,1,5,7,8" \
-        "6  0    0 pop_vlan,2,push_vlan(vid=10,pcp=0),0,1,5,7,8" \
-        "6  0    1 pop_vlan,2,push_vlan(vid=10,pcp=1),0,1,5,7,8" \
+        "5  12   1 0,1,6,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=0,pcp=1),3,8" \
+        "6  none 0 2,push_vlan(tpid=0x8100,vid=10,pcp=0),0,1,5,7,8" \
+        "6  0    0 pop_vlan,2,push_vlan(tpid=0x8100,vid=10,pcp=0),0,1,5,7,8" \
+        "6  0    1 pop_vlan,2,push_vlan(tpid=0x8100,vid=10,pcp=1),0,1,5,7,8" \
         "6  10   0 0,1,5,7,8,pop_vlan,2" \
         "6  10   1 0,1,5,7,8,pop_vlan,2" \
         "6  11   0 drop" \
         "6  11   1 drop" \
         "6  12   0 0,1,5,pop_vlan,3,4,7,8" \
-        "6  12   1 0,1,5,pop_vlan,4,7,push_vlan(vid=0,pcp=1),3,8" \
-        "7  none 0 3,4,8,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "7  0    0 pop_vlan,3,4,8,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "7  0    1 3,8,pop_vlan,4,push_vlan(vid=12,pcp=1),0,1,5,6" \
+        "6  12   1 0,1,5,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=0,pcp=1),3,8" \
+        "7  none 0 3,4,8,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "7  0    0 pop_vlan,3,4,8,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "7  0    1 3,8,pop_vlan,4,push_vlan(tpid=0x8100,vid=12,pcp=1),0,1,5,6" \
         "7  10   0 0,1,5,6,8,pop_vlan,2" \
         "7  10   1 0,1,5,6,8,pop_vlan,2" \
         "7  11   0 0,5" \
         "7  11   1 0,5" \
         "7  12   0 0,1,5,6,pop_vlan,3,4,8" \
-        "7  12   1 0,1,5,6,pop_vlan,4,push_vlan(vid=0,pcp=1),3,8" \
-        "8  none 0 3,4,7,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "8  0    0 pop_vlan,3,4,7,push_vlan(vid=12,pcp=0),0,1,5,6" \
-        "8  0    1 3,pop_vlan,4,7,push_vlan(vid=12,pcp=1),0,1,5,6" \
+        "7  12   1 0,1,5,6,pop_vlan,4,push_vlan(tpid=0x8100,vid=0,pcp=1),3,8" \
+        "8  none 0 3,4,7,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "8  0    0 pop_vlan,3,4,7,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,5,6" \
+        "8  0    1 3,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=12,pcp=1),0,1,5,6" \
         "8  10   0 0,1,5,6,7,pop_vlan,2" \
         "8  10   1 0,1,5,6,7,pop_vlan,2" \
         "8  11   0 drop" \
         "8  11   1 drop" \
         "8  12   0 0,1,5,6,pop_vlan,3,4,7" \
-        "8  12   1 0,1,5,6,pop_vlan,4,7,push_vlan(vid=0,pcp=1),3"
+        "8  12   1 0,1,5,6,pop_vlan,4,7,push_vlan(tpid=0x8100,vid=0,pcp=1),3"
 do
   set $tuple
   in_port=$1
@@ -860,7 +902,7 @@ AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
 flow="in_port(1),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=1,tos=0,ttl=128,frag=no),icmp(type=8,code=0)"
 AT_CHECK([ovs-appctl ofproto/trace br0 "$flow"], [0], [stdout])
 AT_CHECK_UNQUOTED([tail -1 stdout], [0],
-  [Datapath actions: push_vlan(vid=17,pcp=0),2,pop_vlan,3
+  [Datapath actions: push_vlan(tpid=0x8100,vid=17,pcp=0),2,pop_vlan,3
 ])
 
 flow="in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=1,tos=0,ttl=128,frag=no),icmp(type=8,code=0)"
@@ -891,7 +933,7 @@ flow="in_port(1),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x080
 AT_CHECK([ovs-appctl ofproto/trace br0 "$flow"], [0], [stdout])
 actual=`tail -1 stdout | sed 's/Datapath actions: //'`
 
-expected="2,push_vlan(vid=12,pcp=0),0,1,2"
+expected="2,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,2"
 AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
 mv stdout expout
 AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])
@@ -900,7 +942,7 @@ flow="in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x080
 AT_CHECK([ovs-appctl ofproto/trace br0 "$flow"], [0], [stdout])
 actual=`tail -1 stdout | sed 's/Datapath actions: //'`
 
-expected="push_vlan(vid=17,pcp=0),1,pop_vlan,push_vlan(vid=12,pcp=0),0,1,2"
+expected="push_vlan(tpid=0x8100,vid=17,pcp=0),1,pop_vlan,push_vlan(tpid=0x8100,vid=12,pcp=0),0,1,2"
 AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
 mv stdout expout
 AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])
diff --git a/tests/ofproto.at b/tests/ofproto.at
index d1ea8a0..63582d8 100644
--- a/tests/ofproto.at
+++ b/tests/ofproto.at
@@ -580,21 +580,21 @@ check_async () {
     ovs-ofctl -v packet-out br0 none controller '0001020304050010203040501234'
     if test X"$1" = X"OFPR_ACTION"; then shift;
         echo >>expout "OFPT_PACKET_IN: total_len=14 in_port=NONE (via action) data_len=14 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)"
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)"
     fi
 
     # OFPT_PACKET_IN, OFPR_NO_MATCH (controller_id=123)
     ovs-ofctl -v packet-out br0 none 'controller(reason=no_match,id=123)' '0001020304050010203040501234'
     if test X"$1" = X"OFPR_NO_MATCH"; then shift;
         echo >>expout "OFPT_PACKET_IN: total_len=14 in_port=NONE (via no_match) data_len=14 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)"
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)"
     fi
 
     # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
     ovs-ofctl packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003fb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
     if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
         echo >>expout "OFPT_PACKET_IN: total_len=76 in_port=NONE (via invalid_ttl) data_len=76 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(00:26:b9:8c:b0:f9->00:25:83:df:b4:00) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(172.17.55.13->172.16.0.2) port(55155->53) udp_csum:8f6d"
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:26:b9:8c:b0:f9->00:25:83:df:b4:00) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(172.17.55.13->172.16.0.2) port(55155->53) udp_csum:8f6d"
     fi
 
     # OFPT_PORT_STATUS, OFPPR_ADD
@@ -692,9 +692,9 @@ ovs-appctl -t ovs-ofctl exit
 
 AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
 OFPT_PACKET_IN: total_len=14 in_port=NONE (via action) data_len=14 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 OFPT_PACKET_IN: total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
-priority:0,tunnel:0,in_port:0000,tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:5678,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
+priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:5678,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
 OFPT_BARRIER_REPLY:
 ])
 
diff --git a/utilities/ovs-dpctl.c b/utilities/ovs-dpctl.c
index 1322994..29eb45b 100644
--- a/utilities/ovs-dpctl.c
+++ b/utilities/ovs-dpctl.c
@@ -886,11 +886,13 @@ do_normalize_actions(int argc, char *argv[])
         switch(nl_attr_type(a)) {
         case OVS_ACTION_ATTR_POP_VLAN:
             flow.vlan_tci = htons(0);
+            flow.vlan_tpid = htons(0);
             continue;
 
         case OVS_ACTION_ATTR_PUSH_VLAN:
             push = nl_attr_get_unspec(a, sizeof *push);
             flow.vlan_tci = push->vlan_tci;
+            flow.vlan_tpid = push->vlan_tpid;
             continue;
 
         case OVS_ACTION_ATTR_PUSH_MPLS:
diff --git a/utilities/ovs-ofctl.8.in b/utilities/ovs-ofctl.8.in
index def22e5..1c34345 100644
--- a/utilities/ovs-ofctl.8.in
+++ b/utilities/ovs-ofctl.8.in
@@ -375,6 +375,19 @@ Matches IEEE 802.1q Priority Code Point (PCP) \fIpriority\fR, which is
 specified as a value between 0 and 7, inclusive.  A higher value
 indicates a higher frame priority level.
 .
+.IP \fBdl_vlan_tpid=\fIvlan_tpid\fR
+Matches IEEE 802.1ad outer Virtual LAN tpid \fIvlan_tpid\fR. Specify either
+0x88a8 or 0x8100 as a tpid to match.
+.
+.IP \fBdl_vlan_qinq_vid=\fIvlan\fR
+Matches IEEE 802.1ad inner Virtual LAN tag \fIvlan\fR. Specify a number
+between 0 and 4095, inclusive, as the 12-bit VLAN ID to match.
+.
+.IP \fBdl_vlan_qinq_pcp=\fIpriority\fR
+Matches IEEE 802.1ad inner Priority Code Point (PCP) \fIpriority\fR, which is
+specified as a value between 0 and 7, inclusive.  A higher value
+indicates a higher frame priority level.
+.
 .IP \fBdl_src=\fIxx\fB:\fIxx\fB:\fIxx\fB:\fIxx\fB:\fIxx\fB:\fIxx\fR
 .IQ \fBdl_dst=\fIxx\fB:\fIxx\fB:\fIxx\fB:\fIxx\fB:\fIxx\fB:\fIxx\fR
 Matches an Ethernet source (or destination) address specified as 6
@@ -856,6 +869,11 @@ as necessary to match the value specified.  Valid values are between 0
 (lowest) and 7 (highest).  If the VLAN tag is added, a vid of zero is used 
 (see the \fBmod_vlan_vid\fR action to set this).
 .
+.IP \fBpush_vlan\fR:\fIvlan_tpid\fR
+Push new VLAN tag with the tpid specified. VLAN vid and priority of existing
+vlan header is copied onto the new VLAN QinQ header. VLAN CFI for 8021Q or
+VLAN DEI for 8021AD is ignored.
+.
 .IP \fBstrip_vlan\fR
 Strips the VLAN tag from a packet if it is present.
 .
-- 
1.7.5.4

